<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DEM-CSV SalÄ«dzinÄÅ¡ana</title>
  <!-- Pievienojam papaparse bibliotÄ“ku CSV apstrÄdei -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" crossorigin="anonymous"></script>
  <!-- Pievienojam geotiff.js bibliotÄ“ku GeoTIFF nolasÄ«Å¡anai -->
  <script src="https://unpkg.com/geotiff@2.1.0/dist-browser/geotiff.js" crossorigin="anonymous"></script>
  <!-- Pievienojam SheetJS (xlsx) bibliotÄ“ku Excel (.xlsx) eksportam -->
  <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
  <!-- Pievienojam laz-perf bibliotÄ“ku LAZ failu dekompresijas atbalstam -->
  <script src="https://unpkg.com/laz-perf@1.6.0/dist/laz-perf.js" crossorigin="anonymous"></script>
  <!-- Pievienojam Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/proj4@2.9.0/dist/proj4.js" crossorigin="anonymous"></script>
  <style>
    /* =========================================
       BÄ€ZES (GaiÅ¡ie) STILI
       ========================================= */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, 
                   "Apple Color Emoji", "Segoe UI Emoji";
      margin: 20px;
      background-color: #f8f9fa;
      color: #262730;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 20px;
      text-align: center;
    }
    h3, h4, p, li {
      font-size: 1em;
    }
    #results table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
      background-color: white;
    }
    #results th, #results td {
      border: 1px solid #ccc;
      padding: 8px 12px;
      text-align: left;
    }
    #error {
      color: red;
      font-weight: bold;
      margin-top: 10px;
    }
    #status {
      margin-top: 10px;
      color: #333;
    }
    button {
      background-color: #0099ff;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #007acc;
    }
    .reset-button {
      background-color: #dc3545 !important;
      color: white;
    }
    .reset-button:hover {
      background-color: #c82333 !important;
    }
    input[type="file"], input[type="number"] {
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
      width: 100%;
      box-sizing: border-box;
      font-size: 14px;
    }
    .legend {
      padding: 8px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-top: 20px;
      line-height: 18px;
      color: #555;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      opacity: 0.7;
    }
    .button-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    .download-link {
      text-decoration: none;
      background-color: #28a745;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 16px;
      display: inline-block;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .download-link:hover {
      background-color: #218838;
    }
    #map {
      height: 800px; /* updated height */
      width: 100%;
      margin: 20px 0;
    }
    .diff-label {
      font-size: 12px;
      color: black;
      background: rgba(255,255,255,0.7);
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid #ccc;
    }
    /* FiksÄ“ta tabulas konteineram augstums 300px un fiksÄ“ta galvene */
    .result-table-container {
      height: 300px;
      overflow-y: auto;
      overflow-x: auto; /* pievienots responsivitÄtei */
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    table thead th {
      position: sticky;
      top: 0;
      background: #eee;
      z-index: 1;
    }
    /* =========================================
       TUMÅ AIS REÅ½ÄªMS
       ========================================= */
    body.dark-mode {
      background-color: #121212;
      color: #ffffff;
    }
    body.dark-mode h1,
    body.dark-mode h3,
    body.dark-mode h4,
    body.dark-mode p,
    body.dark-mode li {
      color: #fff;
    }
    body.dark-mode #results table {
      background-color: #1e1e1e;
      border-color: #444;
    }
    body.dark-mode #results th,
    body.dark-mode #results td {
      border-color: #444;
      color: #ccc;
    }
    body.dark-mode .legend {
      background-color: #1e1e1e;
      border-color: #444;
      color: #ccc;
    }
    body.dark-mode .leaflet-control-layers-expanded {
      background: #2b2b2b;
      color: #ccc;
    }
    body.dark-mode .leaflet-popup-content-wrapper {
      background: #2b2b2b;
      color: #ccc;
    }
    body.dark-mode .leaflet-popup-tip-container {
      opacity: 0.7;
    }
    .dark-mode-switch-container {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 20px;
      z-index: 9999;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    body.dark-mode .dark-mode-switch-container {
      background: rgba(0, 0, 0, 0.5);
    }
    #darkModeSwitch {
      transform: scale(1.3);
      cursor: pointer;
    }
    .dark-mode-switch-label {
      font-weight: 500;
      cursor: pointer;
      user-select: none;
    }
    body.dark-mode input[type="file"],
    body.dark-mode input[type="number"] {
      background-color: #2b2b2b;
      color: #ffffff;
      border: 1px solid #444;
    }
    body.dark-mode #status {
      color: #ffffff;
    }
    
    /* Radio pogu stili */
    input[type="radio"] {
      margin-right: 5px;
    }
    
    label {
      margin-right: 15px;
      cursor: pointer;
      user-select: none;
    }
    
    body.dark-mode label {
      color: #ffffff;
    }
    
    /* ResponsÄ«vi pielÄgoti stili */
    @media (max-width: 768px) {
      #map {
        height: 400px;
      }
    }
    @media (max-width: 480px) {
      #map {
        height: 300px;
      }
    }
    
    /* Failu saraksta stili */
    .file-list {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      margin-top: 5px;
      font-size: 12px;
      max-height: 100px;
      overflow-y: auto;
    }
    
    body.dark-mode .file-list {
      background-color: #2b2b2b;
      border-color: #444;
      color: #ccc;
    }
    
    .file-item {
      margin-bottom: 3px;
      padding: 2px 4px;
      background-color: rgba(0, 123, 255, 0.1);
      border-radius: 3px;
    }
    
    body.dark-mode .file-item {
      background-color: rgba(0, 123, 255, 0.2);
    }
  </style>
</head>
<body>
  <!-- TumÅ¡Ä reÅ¾Ä«ma slÄ“dzis (augÅ¡Ä“jÄ labajÄ stÅ«rÄ«) -->
  <div class="dark-mode-switch-container">
    <label for="darkModeSwitch" class="dark-mode-switch-label">TumÅ¡ais reÅ¾Ä«ms</label>
    <input type="checkbox" id="darkModeSwitch" />
  </div>

  <!-- GalvenÄ satura sadaÄ¼a -->
  <h1>Punktu datu un GeoTIFF salÄ«dzinÄÅ¡anas rÄ«ks</h1>
  <p>AugÅ¡upielÄdÄ“jiet punktu datus (CSV vai LAS failu ar x, y, z koordinÄtÄm) un GeoTIFF, lai iegÅ«tu starpÄ«bu aprÄ“Ä·inu.</p>

  <p><strong>Punktu dati:</strong></p>
  <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
    <input type="radio" id="csvOption" name="dataType" value="csv" checked>
    <label for="csvOption">CSV fails</label>
    <input type="radio" id="lasOption" name="dataType" value="las">
    <label for="lasOption">LAS/LAZ faili (var izvÄ“lÄ“ties vairÄkus)</label>
  </div>
  <input type="file" id="csvFile" accept=".csv" />
  <input type="file" id="lasFile" accept=".las,.laz" multiple style="display: none;" />
  <div id="selectedFilesInfo" style="display: none;"></div>

  <p><strong>GeoTIFF fails:</strong></p>
  <input type="file" id="tiffFile" accept=".tif, .tiff" multiple />
  <div id="tiffFileList" style="margin-top: 5px; font-size: 0.9em; color: #666;"></div>

  <p><strong>Punktu attÄ“loÅ¡ana kartÄ“:</strong></p>
  <div style="margin-bottom: 10px;">
    <label for="samplingSlider">Sampling % (0% = visi punkti, 100% = neviens punkts):</label>
    <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
      <input type="range" id="samplingSlider" min="0" max="50" value="0" style="flex: 1;">
      <span id="samplingValue" style="font-weight: bold; min-width: 40px;">0%</span>
    </div>
    <div style="font-size: 0.9em; color: #666; margin-top: 3px;">
      <span id="samplingDescription">Visi punkti tiks attÄ“loti kartÄ“</span>
    </div>
  </div>

  <!-- DarbÄ«bu pogu konteiners -->
  <div class="button-container">
    <button id="processBtn">ApstrÄdÄt</button>
    <button id="downloadBtn" style="display:none;">LejupielÄdÄ“t GeoJSON</button>
    <button id="downloadDXFBtn" style="display:none;">LejupielÄdÄ“t DXF</button>
    <button id="downloadExcelBtn" style="display:none;">LejupielÄdÄ“t tabulu CSV</button>
    <button id="downloadXlsxBtn" style="display:none;">LejupielÄdÄ“t tabulu Excel</button>
    <button id="resetBtn" class="reset-button" style="display:none;">Jauna apstrÄde</button>
  </div>
  <div id="progressContainer" style="margin: 10px 0;">
    <progress id="progressBar" value="0" max="100" style="width: 100%; display: none;"></progress>
  </div>

  <div id="status"></div>
  <div id="error"></div>

  <!-- Karte -->
  <div id="map"></div>

  <!-- RezultÄtu tabula un statistika -->
  <div id="results">
    <div id="geojsonTable"></div>
    <br/>
    <div id="statistics"></div>
  </div>

  <script>
    // TumÅ¡Ä reÅ¾Ä«ma slÄ“dzis
    document.getElementById('darkModeSwitch').addEventListener('change', function() {
      document.body.classList.toggle('dark-mode', this.checked);
    });

    // Radio pogu funkcionalitÄte failu tipu izvÄ“lei
    document.getElementById('csvOption').addEventListener('change', function() {
      if (this.checked) {
        document.getElementById('csvFile').style.display = 'block';
        document.getElementById('lasFile').style.display = 'none';
        document.getElementById('selectedFilesInfo').style.display = 'none';
      }
    });

    document.getElementById('lasOption').addEventListener('change', function() {
      if (this.checked) {
        document.getElementById('csvFile').style.display = 'none';
        document.getElementById('lasFile').style.display = 'block';
        document.getElementById('selectedFilesInfo').style.display = 'block';
      }
    });

    // Pievienojam failu saraksta atjaunoÅ¡anu
    document.getElementById('lasFile').addEventListener('change', function() {
      updateSelectedFilesInfo(this.files);
    });
    
    // Pievienojam TIFF failu saraksta atjaunoÅ¡anu
    document.getElementById('tiffFile').addEventListener('change', function() {
      updateTiffFilesInfo(this.files);
    });
    
    // Sampling slider funkcionalitÄte
    document.getElementById('samplingSlider').addEventListener('input', function() {
      updateSamplingDisplay(this.value);
    });
    
    function updateSamplingDisplay(value) {
      const samplingValue = document.getElementById('samplingValue');
      const samplingDescription = document.getElementById('samplingDescription');
      
      samplingValue.textContent = value + '%';
      
      if (value == 0) {
        samplingDescription.textContent = 'Visi punkti tiks attÄ“loti kartÄ“';
      } else if (value <= 5) {
        samplingDescription.textContent = `Katrs ${Math.round(100/value)}. punkts tiks attÄ“lots (${100-value}% punktu)`;
      } else if (value <= 10) {
        samplingDescription.textContent = `Katrs ${Math.round(100/value)}. punkts tiks attÄ“lots (${100-value}% punktu)`;
      } else if (value <= 20) {
        samplingDescription.textContent = `Katrs ${Math.round(100/value)}. punkts tiks attÄ“lots (${100-value}% punktu)`;
      } else {
        samplingDescription.textContent = `Ä»oti maz punktu tiks attÄ“lots (${100-value}% punktu)`;
      }
    }
    
    // InicializÄ“jam display
    updateSamplingDisplay(0);

    function updateSelectedFilesInfo(files) {
      const infoDiv = document.getElementById('selectedFilesInfo');
      if (files.length === 0) {
        infoDiv.style.display = 'none';
        return;
      }
      
      let totalSize = 0;
      let fileListHtml = '<div class="file-list"><strong>IzvÄ“lÄ“tie LAS faili:</strong><br>';
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        totalSize += file.size;
        const sizeStr = (file.size / 1024 / 1024).toFixed(1);
        fileListHtml += `<div class="file-item">${i + 1}. ${file.name} (${sizeStr} MB)</div>`;
      }
      
      const totalSizeStr = (totalSize / 1024 / 1024).toFixed(1);
      fileListHtml += `<br><strong>KopÄ: ${files.length} faili, ${totalSizeStr} MB</strong></div>`;
      
      infoDiv.innerHTML = fileListHtml;
      infoDiv.style.display = 'block';
    }
    
    function updateTiffFilesInfo(files) {
      const infoDiv = document.getElementById('tiffFileList');
      if (files.length === 0) {
        infoDiv.style.display = 'none';
        return;
      }
      
      let totalSize = 0;
      let fileListHtml = '<div class="file-list"><strong>IzvÄ“lÄ“tie GeoTIFF faili:</strong><br>';
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        totalSize += file.size;
        const sizeStr = (file.size / 1024 / 1024).toFixed(1);
        fileListHtml += `<div class="file-item">${i + 1}. ${file.name} (${sizeStr} MB)</div>`;
      }
      
      const totalSizeStr = (totalSize / 1024 / 1024).toFixed(1);
      fileListHtml += `<br><strong>KopÄ: ${files.length} faili, ${totalSizeStr} MB</strong></div>`;
      
      infoDiv.innerHTML = fileListHtml;
      infoDiv.style.display = 'block';
    }

    // JÅ«su esoÅ¡ais JS kods:
    let csvData = null;
    let tiffArray = null;
    let geoTransform = null;
    let imageWidth = 0;
    let imageHeight = 0;
    let tiePoint = [];
    let pixelScale = [];
    let currentGeojsonData = null; // saglabÄjam pilno GeoJSON pÄ“c apstrÄdes
    let map = null;
    let resultFileName = "";


    // DefinÄ“jiet LKS-92 projekciju
    proj4.defs("EPSG:3059", "+proj=tmerc +lat_0=0 +lon_0=24 +k=0.9996 +x_0=500000 +y_0=-6000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    // Kartes inicializÄcija
    function initMap() {
      if (map) {
        map.remove();
      }
      
      map = L.map('map').setView([56.946285, 24.105078], 7);
      
      // DefinÄ“jam pamatkarÅ¡u slÄÅ†us
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      });
    
      const ortofoto = L.tileLayer.wms('https://lvmgeoserver.lvm.lv/geoserver/ows', {
        layers: 'public:Orto_LKS',
        format: 'image/png',
        transparent: true,
        version: '1.3.0',
        attribution: '&copy; <a href="https://www.lgia.gov.lv/">LÄ¢IA</a>'
      });
    
      // Izveidojam pamatkarÅ¡u kontrolieri
      const baseMaps = {
        "OpenStreetMap": osm,
        "LÄ¢IA Ortofoto": ortofoto
      };
    
      // Pievienojam noklusÄ“juma karti
      osm.addTo(map);
    
      // Pievienojam slÄÅ†u kontrolieri, iestatot collapsed: false, lai tas bÅ«tu atvÄ“rts
      L.control.layers(baseMaps, null, { position: 'topleft', collapsed: false }).addTo(map);
    }

    // Global canvas renderer for better performance with many points
    const canvasRenderer = L.canvas({ padding: 0.5 });

    // Funkcija punktu krÄsas noteikÅ¡anai
    function getDiffColor(diff) {
      if (diff >= 1.0) return '#FF0000';
      if (diff >= 0.5) return '#C80032';
      if (diff >= 0.2) return '#E57373';
      if (diff >= 0.1) return '#FFCDD2';
      if (diff >= 0) return '#8BC34A';
      if (diff >= -0.1) return '#8BC34A';
      if (diff >= -0.2) return '#B3E5FC';
      if (diff >= -0.5) return '#64B5F6';
      if (diff >= -1.0) return '#1976D2';
      return '#0000FF';
    }

    // Funkcija punktu vizualizÄcijai kartÄ“
    function visualizePoints(geojsonData) {
      if (!map) {
        initMap();
      }
      // Remove previous point layers if they exist
      if (window.pointLayers) {
        Object.values(window.pointLayers).forEach(layer => {
          if (map.hasLayer(layer)) { map.removeLayer(layer); }
        });
      }
      // Remove previous text (tx) layers if they exist
      if (window.diffLayers) {
        Object.values(window.diffLayers).forEach(layer => {
          if (map.hasLayer(layer)) { map.removeLayer(layer); }
        });
      }
      
      // Point layers already initialized in createGeoJSON
      
      // Initialize text layers (using "tx" prefix, default off)
      window.diffLayers = {
        "tx virs 1.0 m": L.layerGroup(),
        "tx 0.5â€“1.0 m": L.layerGroup(),
        "tx 0.2â€“0.5 m": L.layerGroup(),
        "tx 0.1â€“0.2 m": L.layerGroup(),
        "tx lÄ«dz 0.1 m": L.layerGroup(),
        "tx -0.1â€“0 m": L.layerGroup(),
        "tx -0.2â€“ -0.1 m": L.layerGroup(),
        "tx -0.5â€“ -0.2 m": L.layerGroup(),
        "tx -1.0â€“ -0.5 m": L.layerGroup(),
        "tx zem -1.0 m": L.layerGroup()
      };

      // Points are now added directly during createGeoJSON process
      console.log(`ğŸ¨ Punkti jau pievienoti slÄÅ†os createGeoJSON procesÄ`);
      
      // Create bounds group from existing layers
      const allMarkersGroup = L.featureGroup();
      Object.values(window.pointLayers).forEach(layer => {
        layer.eachLayer(marker => allMarkersGroup.addLayer(marker));
      });
      
      // Zoom-based point loading to prevent memory issues
      const MIN_ZOOM_FOR_POINTS = 12; // Show points only when zoomed in
      const defaultVisibleLayers = [
        "Î”Z lÄ«dz 0.1 m",
        "Î”Z -0.1â€“0 m"
      ];
      
      // Function to manage point visibility based on zoom
      function updatePointVisibility() {
        const currentZoom = map.getZoom();
        const shouldShowPoints = currentZoom >= MIN_ZOOM_FOR_POINTS;
        
        defaultVisibleLayers.forEach(layerName => {
          if (window.pointLayers[layerName]) {
            if (shouldShowPoints && !map.hasLayer(window.pointLayers[layerName])) {
              window.pointLayers[layerName].addTo(map);
              console.log(`ğŸ” Zoom ${currentZoom}: ParÄdÄ«ti ${layerName} punkti`);
            } else if (!shouldShowPoints && map.hasLayer(window.pointLayers[layerName])) {
              map.removeLayer(window.pointLayers[layerName]);
              console.log(`ğŸ” Zoom ${currentZoom}: PaslÄ“pti ${layerName} punkti`);
            }
          }
        });
      }
      
      // Add zoom event listener
      map.on('zoomend', updatePointVisibility);
      
      // Initial check
      updatePointVisibility();
      
      // Build the overlay object in the desired order:
      const overlaysOrdered = {
        ". 1.0 m un vairÄk": window.pointLayers["Î”Z virs 1.0 m"],
        "t 1.0 m un vairÄk": window.diffLayers["tx virs 1.0 m"],
        ". 0.5â€“1.0 m": window.pointLayers["Î”Z 0.5â€“1.0 m"],
        "t 0.5â€“1.0 m": window.diffLayers["tx 0.5â€“1.0 m"],
        ". 0.2â€“0.5 m": window.pointLayers["Î”Z 0.2â€“0.5 m"],
        "t 0.2â€“0.5 m": window.diffLayers["tx 0.2â€“0.5 m"],
        ". 0.1â€“0.2 m": window.pointLayers["Î”Z 0.1â€“0.2 m"],
        "t 0.1â€“0.2 m": window.diffLayers["tx 0.1â€“0.2 m"],
        ". 0.1 m": window.pointLayers["Î”Z lÄ«dz 0.1 m"],
        "t 0.1 m": window.diffLayers["tx lÄ«dz 0.1 m"],
        ". -0.1â€“0 m": window.pointLayers["Î”Z -0.1â€“0 m"],
        "t -0.1â€“0 m": window.diffLayers["tx -0.1â€“0 m"],
        ". -0.2â€“ -0.1 m": window.pointLayers["Î”Z -0.2â€“ -0.1 m"],
        "t -0.2â€“ -0.1 m": window.diffLayers["tx -0.2â€“ -0.1 m"],
        ". -0.5â€“ -0.2 m": window.pointLayers["Î”Z -0.5â€“ -0.2 m"],
        "t -0.5â€“ -0.2 m": window.diffLayers["tx -0.5â€“ -0.2 m"],
        ". -1.0â€“ -0.5 m": window.pointLayers["Î”Z -1.0â€“ -0.5 m"],
        "t -1.0â€“ -0.5 m": window.diffLayers["tx -1.0â€“ -0.5 m"],
        ". -1.0 m un vairÄk": window.pointLayers["Î”Z zem -1.0 m"],
        "t -1.0 m un vairÄk": window.diffLayers["tx zem -1.0 m"]
      };
      
      // Add text layers in one go (they remain off by default)
      Object.values(window.diffLayers).forEach(layer => { /* not added by default */ });
      
      if (window.layerControl) { map.removeControl(window.layerControl); }
      window.layerControl = L.control.layers(null, overlaysOrdered, { collapsed: false, position: 'topright' }).addTo(map);
      
      if (allMarkersGroup.getLayers().length > 0) {
        map.fitBounds(allMarkersGroup.getBounds());
      }
      addLegend();
    }

    // Poga, kas sÄk apstrÄdi
    document.getElementById("processBtn").addEventListener("click", async () => {
      const csvFileInput = document.getElementById("csvFile");
      const lasFileInput = document.getElementById("lasFile");
      const tiffFileInput = document.getElementById("tiffFile");
      const isCSVSelected = document.getElementById("csvOption").checked;
      const isLASSelected = document.getElementById("lasOption").checked;

      // PÄrbaudam, vai ir izvÄ“lÄ“ti nepiecieÅ¡amie faili
      if (isCSVSelected && !csvFileInput.files.length) {
        alert("LÅ«dzu izvÄ“lieties CSV failu!");
        return;
      }
      if (isLASSelected && !lasFileInput.files.length) {
        alert("LÅ«dzu izvÄ“lieties vismaz vienu LAS failu!");
        return;
      }
      if (!tiffFileInput.files.length) {
        alert("LÅ«dzu izvÄ“lieties GeoTIFF failu!");
        return;
      }

      // Izveidojam dinamisko rezultÄtu faila nosaukumu
      const tiffFileName = tiffFileInput.files[0].name;
      const baseName = tiffFileName.replace(/\.[^/.]+$/, ""); // noÅ†emam paplaÅ¡inÄjumu
      const now = new Date();
      const dateStr = now.getFullYear().toString() +
                     ("0" + (now.getMonth() + 1)).slice(-2) +
                     ("0" + now.getDate()).slice(-2);
      
      // Pievienojam informÄciju par vairÄkiem LAS failiem
      let fileInfo = "";
      if (isLASSelected && lasFileInput.files.length > 1) {
        fileInfo += `_${lasFileInput.files.length}LAS`;
      }
      if (tiffFileInput.files.length > 1) {
        fileInfo += `_${tiffFileInput.files.length}TIFF`;
      }
      
      resultFileName = `${baseName}${fileInfo}_starpibu_atskaite_${dateStr}`;

      document.getElementById("status").innerText = "ApstrÄde sÄkas...";
      const progress = document.getElementById("progressBar");
      if(progress) { progress.style.display = "inline-block"; progress.value = 0; }
      
      try {
        document.getElementById("error").innerHTML = "";
        
        // SÄkuma atmiÅ†as stÄvoklis
        logMemoryUsage('SÄkums:');
        
        // NolasÄm punktu datus atkarÄ«bÄ no izvÄ“lÄ“tÄ tipa
        if (isCSVSelected) {
          await readCSV(csvFileInput.files[0]);
        } else if (isLASSelected) {
          await readMultipleLAS(lasFileInput.files);
        }
        logMemoryUsage('PÄ“c punktu ielÄdes:');
        if(progress) { progress.value = 30; }
        
        // Nododam LAS robeÅ¾as GeoTIFF lasÄ«Å¡anai optimizÄcijai
        const lasBounds = csvData && csvData.bounds ? csvData.bounds : null;
        console.log(`ğŸ” LAS robeÅ¾as optimizÄcijai:`, lasBounds);
        
        if (!lasBounds) {
          console.warn(`âš ï¸ Nav LAS robeÅ¾u - nevar optimizÄ“t GeoTIFF ielÄdi!`);
        }
        
        if (tiffFileInput.files.length === 1) {
        await readGeoTIFF(tiffFileInput.files[0], lasBounds);
        } else {
          await readMultipleGeoTIFF(tiffFileInput.files, lasBounds);
        }
        logMemoryUsage('PÄ“c GeoTIFF ielÄdes:');
        if(progress) { progress.value = 60; }
        
        // Debug informÄcija pirms createGeoJSON
        console.log('ğŸ” DEBUG stÄvoklis pirms createGeoJSON:');
        console.log(`   csvData: ${csvData ? csvData.length : 'null'} punkti`);
        console.log(`   geoTransform: ${geoTransform ? 'OK' : 'null'}`);
        console.log(`   tiffArray: ${tiffArray ? 'OK' : 'null'}`);
        console.log(`   geoTiffImage: ${geoTiffImage ? 'OK' : 'null'}`);
        
        if (csvData && csvData.length > 0 && geoTransform && (tiffArray || geoTiffImage)) {
          const geojsonData = await createGeoJSON();
          currentGeojsonData = geojsonData;
          if(progress) { progress.value = 80; }
          
          if (geojsonData.features.length === 0) {
            throw new Error("Nav atrasti derÄ«gi punkti! PÄrbaudiet, vai faili pÄrklÄj to paÅ¡u teritoriju.");
          }
          
          displayGeojsonAsTable(geojsonData);
          await computeStatistics();
          if(progress) { progress.value = 100; }
          
          document.getElementById("downloadBtn").style.display = "inline-block";
          document.getElementById("downloadDXFBtn").style.display = "inline-block";
          document.getElementById("downloadExcelBtn").style.display = "inline-block";
          document.getElementById("downloadXlsxBtn").style.display = "inline-block";
          document.getElementById("resetBtn").style.display = "inline-block";
          
          setTimeout(() => { if(progress) { progress.style.display = "none"; } }, 1000);
          visualizePoints(geojsonData);
          
          // Count actual points in all layers
          let totalPointsInLayers = 0;
          if (window.pointLayers) {
            Object.values(window.pointLayers).forEach(layer => {
              totalPointsInLayers += layer.getLayers().length;
            });
          }
          
          document.getElementById("status").innerText = `ApstrÄde pabeigta! KartÄ“ attÄ“loti ${totalPointsInLayers.toLocaleString()} punkti.`;
        } else {
          // DetalizÄ“ts kÄ¼Å«das ziÅ†ojums
          let errorDetails = "Datu ielÄde neizdevÄs:";
          if (!csvData || csvData.length === 0) {
            errorDetails += "\nâŒ LAS dati nav ielÄdÄ“ti vai ir tukÅ¡i";
          }
          if (!geoTransform) {
            errorDetails += "\nâŒ GeoTIFF Ä£eoreferences informÄcija nav pieejama";
          }
          if (!tiffArray && !geoTiffImage) {
            errorDetails += "\nâŒ GeoTIFF dati nav ielÄdÄ“ti";
          }
          errorDetails += "\n\nğŸ’¡ PÄrbaudiet failu formÄtus un to saderÄ«bu!";
          
          throw new Error(errorDetails);
        }
      } catch (error) {
        console.error('ApstrÄdes kÄ¼Å«da:', error);
        document.getElementById("error").innerHTML = `<strong>KÄ¼Å«da:</strong> ${error.message}`;
        document.getElementById("status").innerText = "ApstrÄde pÄrtraukta ar kÄ¼Å«du.";
        if(progress) { progress.style.display = "none"; }
      }
    });

    // Funkcija, kas vizualizÄ“ GeoJSON rezultÄtu tabulÄ
    function displayGeojsonAsTable(geojsonData) {
      let tableHtml = "<h4>StarpÄ«bu saraksts, pirmÄs 100 rindas</h4><table><thead><tr><th>#</th><th>Punkta_X</th><th>Punkta_Y</th><th>Punkta_Z</th><th>DEM_Z</th><th>Diff</th></tr></thead><tbody>";
      const featuresToDisplay = geojsonData.features.slice(0, 100);
      featuresToDisplay.forEach((feature, index) => {
        tableHtml += "<tr>";
        tableHtml += "<td>" + (index + 1) + "</td>";
        tableHtml += "<td>" + feature.properties.CSV_X.toFixed(2) + "</td>";
        tableHtml += "<td>" + feature.properties.CSV_Y.toFixed(2) + "</td>";
        tableHtml += "<td>" + feature.properties.CSV_Z.toFixed(2) + "</td>";
        tableHtml += "<td>" + feature.properties.DEM_Z.toFixed(2) + "</td>";
        tableHtml += "<td>" + feature.properties.difference.toFixed(2) + "</td>";
        tableHtml += "</tr>";
      });
      tableHtml += "</tbody></table>";
      // Ievieto tabulu tieÅ¡i zem "MÄ«nus vÄ“rtÄ«bas" tabulas, izmantojot insertAdjacentHTML("afterend")
      document.getElementById("statistics").insertAdjacentHTML("afterend", "<div class='result-table-container'>" + tableHtml + "</div>");
    }

    // Poga lejupielÄdei
    document.getElementById("downloadBtn").addEventListener("click", () => {
      if (currentGeojsonData) {
        const text = JSON.stringify(currentGeojsonData, null, 2);
        downloadFile(`${resultFileName}.geojson`, text);
      }
    });

    // Poga DXF lejupielÄdei
    document.getElementById("downloadDXFBtn").addEventListener("click", () => {
      const dxfText = createDXF();
      downloadFile(`${resultFileName}.dxf`, dxfText);
    });

    // LejupielÄdes pogas Excel CSV
    document.getElementById("downloadExcelBtn").addEventListener("click", () => {
      if (currentGeojsonData) {
        const csvContent = exportTableAsCSV(currentGeojsonData);
        downloadCSVFile(`${resultFileName}.csv`, csvContent);
      }
    });

    // LejupielÄdes pogas XLSX
    document.getElementById("downloadXlsxBtn").addEventListener("click", () => {
      if (currentGeojsonData) {
        exportTableAsXLSX(currentGeojsonData);
      }
    });
    
    // Jauna apstrÄde poga
    document.getElementById("resetBtn").addEventListener("click", () => {
      resetApplication();
    });

    function resetApplication() {
      // DzÄ“Å¡am visus datus
      csvData = null;
      tiffArray = null;
      geoTransform = null;
      imageWidth = 0;
      imageHeight = 0;
      tiePoint = null;
      pixelScale = null;
      geoTiffImage = null;
      currentGeojsonData = null;
      resultFileName = "";
      
      // DzÄ“Å¡am papildu GeoTIFF attÄ“lus
      if (window.additionalGeoTiffImages) {
        window.additionalGeoTiffImages = [];
      }
      
      // DzÄ“Å¡am punktu slÄÅ†us no kartes
      if (window.pointLayers) {
        Object.values(window.pointLayers).forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
          layer.clearLayers();
        });
        window.pointLayers = null;
      }
      
      // DzÄ“Å¡am teksta slÄÅ†us
      if (window.diffLayers) {
        Object.values(window.diffLayers).forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
          layer.clearLayers();
        });
        window.diffLayers = null;
      }
      
      // AtiestatÄm failu ievades laukus
      document.getElementById("csvFile").value = "";
      document.getElementById("lasFile").value = "";
      document.getElementById("tiffFile").value = "";
      
      // PaslÄ“pjam failu sarakstus
      document.getElementById("selectedFilesInfo").style.display = "none";
      document.getElementById("tiffFileList").style.display = "none";
      
      // PaslÄ“pjam pogas
      document.getElementById("downloadBtn").style.display = "none";
      document.getElementById("downloadDXFBtn").style.display = "none";
      document.getElementById("downloadExcelBtn").style.display = "none";
      document.getElementById("downloadXlsxBtn").style.display = "none";
      document.getElementById("resetBtn").style.display = "none";
      
      // PaslÄ“pjam progress bar
      const progress = document.getElementById("progressBar");
      if (progress) {
        progress.style.display = "none";
        progress.value = 0;
      }
      
      // DzÄ“Å¡am status un error ziÅ†ojumus
      document.getElementById("status").innerText = "";
      document.getElementById("error").innerHTML = "";
      
      // DzÄ“Å¡am statistikas un tabulas
      const statisticsDiv = document.getElementById("statistics");
      if (statisticsDiv) {
        statisticsDiv.innerHTML = "";
      }
      
      // DzÄ“Å¡am rezultÄtu tabulas
      const resultTables = document.querySelectorAll('.result-table-container');
      resultTables.forEach(table => table.remove());
      
      // DzÄ“Å¡am cache
      if (typeof geoTiffCache !== 'undefined') {
        geoTiffCache.clear();
      }
      
      console.log("ğŸ”„ AplikÄcija atiestatÄ«ta - gatava jaunai apstrÄdei!");
    }

    async function readCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            results.data = results.data.map(row => {
              const newRow = {};
              Object.keys(row).forEach(key => {
                newRow[key.toLowerCase()] = row[key];
              });
              return newRow;
            });
            if (!results.data[0].hasOwnProperty('x') || 
                !results.data[0].hasOwnProperty('y') || 
                !results.data[0].hasOwnProperty('z')) {
              reject("CSV failÄ nav nepiecieÅ¡amÄs kolonnas (x, y, z vai X, Y, Z)");
              return;
            }
            csvData = results.data;
            
            // AprÄ“Ä·inÄm CSV punktu robeÅ¾as
            const bounds = calculateCSVBounds(csvData);
            console.log(`ğŸ“ CSV robeÅ¾as:`, bounds);
            csvData.bounds = bounds;
            
            resolve();
          },
          error: function(err) {
            console.error("KÄ¼Å«da CSV nolasÄ«Å¡anÄ:", err);
            reject(err);
          }
        });
      });
    }

    async function readMultipleLAS(files) {
      return new Promise(async (resolve, reject) => {
        try {
          console.log(`ğŸ—‚ï¸ SÄk vairÄku LAS failu apstrÄdi: ${files.length} faili`);
          
          let allPoints = [];
          let totalFileSize = 0;
          let foundUnclassifiedFiles = false;
          let fileStatusList = []; // Saraksts ar katra faila klasifikÄcijas statusu
          
          // AprÄ“Ä·inÄm kopÄ“jo failu izmÄ“ru
          for (let i = 0; i < files.length; i++) {
            totalFileSize += files[i].size;
          }
          console.log(`ğŸ“Š KopÄ“jais izmÄ“rs: ${(totalFileSize/1024/1024).toFixed(1)}MB`);
          
          // AtmiÅ†as pÄrbaude vairÄku failu gadÄ«jumÄ
          const memory = getMemoryInfo();
          if (memory && totalFileSize > memory.available * 0.3) {
            console.warn(`âš ï¸ BRÄªDINÄ€JUMS: Liels failu izmÄ“rs (${(totalFileSize/1024/1024).toFixed(1)}MB) var pÄrsniegt atmiÅ†as limitus!`);
            console.warn(`ğŸ’¾ PieejamÄ atmiÅ†a: ${(memory.available/1024/1024).toFixed(1)}MB`);
            console.warn(`ğŸ”§ SistÄ“ma automÄtiski optimizÄ“s apstrÄdi`);
          }
          
          // ApstrÄdÄjam katru failu secÄ«gi
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            console.log(`ğŸ“ ApstrÄdÄ failu ${i + 1}/${files.length}: ${file.name} (${(file.size/1024/1024).toFixed(1)}MB)`);
            
            // PielÄgojam izsaukumu, jo tagad readSingleLAS atgrieÅ¾ Promise
            const result = await readSingleLAS(file, i + 1, files.length);
            const filePoints = result.points;
            
            // Ja failÄ ir neklasificÄ“ti punkti, piefiksÄ“jam to
            if (result.hasUnclassifiedWarning) {
              foundUnclassifiedFiles = true;
              console.log(`âš ï¸ Fails ${i + 1}/${files.length}: ${file.name} satur neklasificÄ“tus punktus!`);
              fileStatusList.push({
                name: file.name,
                isClassified: false,
                index: i + 1,
                totalFiles: files.length
              });
            } else {
              fileStatusList.push({
                name: file.name,
                isClassified: true,
                index: i + 1,
                totalFiles: files.length
              });
            }
            
            allPoints = allPoints.concat(filePoints);
            
            // AtjauninÄm statusu
            const progress = ((i + 1) / files.length * 100).toFixed(1);
            document.getElementById('status').textContent = `ğŸ“ LAS ${i + 1}/${files.length} pabeigts (${progress}%) - ${allPoints.length} punkti kopÄ`;
            
            // AgresÄ«va atmiÅ†as tÄ«rÄ«Å¡ana starp failiem
            if (i < files.length - 1) {
              // TÄ«rÄm cache starp failiem
              geoTiffCache.clear();
              
              // Pauze un garbage collection
              await new Promise(resolve => setTimeout(resolve, 200));
              if (typeof gc !== 'undefined') {
                gc();
                console.log(`ğŸ§¹ AtmiÅ†a tÄ«rÄ«ta pÄ“c faila ${i + 1}`);
              }
              
              // AtmiÅ†as stÄvokÄ¼a pÄrbaude
              logMemoryUsage(`PÄ“c faila ${i + 1}:`);
            }
          }
          
          console.log(`âœ… Visi LAS faili apstrÄdÄti! KopÄ: ${allPoints.length} punkti`);
          
          // VIENMÄ’R parÄdÄm LAS failu klasifikÄcijas kopsavilkumu
          if (fileStatusList.length > 0) {
            // Izveidojam sarakstu ar neklasificÄ“tiem un klasificÄ“tiem failiem
            const unclassifiedFiles = fileStatusList.filter(item => !item.isClassified);
            const classifiedFiles = fileStatusList.filter(item => item.isClassified);
            
            const unclassifiedNames = unclassifiedFiles.length > 0 ? 
              unclassifiedFiles.map(f => f.name).join(", ") : 
              "Nav neklasificÄ“tu failu";
            const classifiedNames = classifiedFiles.length > 0 ? 
              classifiedFiles.map(f => f.name).join(", ") : 
              "Nav klasificÄ“tu failu";
            
            const warningMessage = `âš ï¸ LAS faili, kuri ir neklasificÄ“ti - visi punkti tiks izmantoti apstrÄde.`;
            console.warn(warningMessage);
            console.warn(`NeklasificÄ“ti faili: ${unclassifiedNames}`);
            console.warn(`KlasificÄ“ti faili: ${classifiedNames}`);
            
            // Pievienojam paziÅ†ojumu arÄ« apstrÄdes beigÄs ar detalizÄ“tu informÄciju par failiem
            document.getElementById('error').innerHTML += `
              <div style="background-color: #FFF3CD; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; font-weight: bold;">
                ${warningMessage} 
                <br><small>Parasti klasificÄ“tos LAS failos ir zemes punktu klasificÄ“tija - (klase 2).</small>
                <hr style="border-top: 1px solid #856404; margin: 8px 0;">
                <div>
                  <strong>NeklasificÄ“ti faili:</strong> ${unclassifiedNames}
                </div>
                <div>
                  <strong>KlasificÄ“ti faili:</strong> ${classifiedNames}
                </div>
              </div>`;
          }
          
          // VIENMÄ’R pievienojam informatÄ«vu paziÅ†ojumu par punktu izmantoÅ¡anu
          document.getElementById('error').innerHTML += `
            <div style="background-color: #E3F2FD; color: #0D47A1; padding: 10px; border-radius: 5px; margin: 10px 0;">
              â„¹ï¸ INFORMÄ€CIJA: ApstrÄdes laikÄ tiek izmantoti visi LAS/LAZ failu punkti, ne tikai klasificÄ“tie zemes (ground) punkti. LAZ faili tiek automÄtiski dekompresÄ“ti.
            </div>`;
          
          // SaglabÄjam failu sarakstu CSV objektÄ
          let fileStatusInfo = [];
          fileStatusInfo.classified = fileStatusList.filter(item => item.isClassified).map(item => item.name);
          fileStatusInfo.unclassified = fileStatusList.filter(item => !item.isClassified).map(item => item.name);
          
          // AprÄ“Ä·inÄm apvienoto robeÅ¾u
          const bounds = calculateLASBounds(allPoints);
          console.log(`ğŸ“ ApvienotÄs LAS robeÅ¾as:`, bounds);
          
          csvData = allPoints;
          csvData.bounds = bounds;
          csvData.fileStatusInfo = fileStatusInfo;
          resolve();
          
        } catch (error) {
          console.error('KÄ¼Å«da vairÄku LAS failu apstrÄdÄ“:', error);
          reject(error);
        }
      });
    }

    async function readSingleLAS(file, fileIndex, totalFiles) {
      return new Promise(async (resolve, reject) => {
        try {
          const isLAZ = file.name.toLowerCase().endsWith('.laz');
          console.log(`${isLAZ ? 'LAZ' : 'LAS'} ${fileIndex}/${totalFiles}: ${file.name}, ${(file.size/1024/1024).toFixed(1)}MB`);
          
          let processedFile = file;
          
          // Ja ir LAZ fails, mÄ“Ä£inÄm dekompresiju
          if (isLAZ) {
            console.log(`ğŸ”„ AtpazÄ«ts LAZ fails: ${file.name}`);
            try {
              // MÄ“Ä£inÄm izmantot laz-perf bibliotÄ“ku, ja tÄ ir pieejama
              if (typeof LazPerf !== 'undefined' && LazPerf.LASDecoder) {
                console.log(`ğŸ”§ Izmantojam laz-perf dekompresiju...`);
                const lazBuffer = await file.arrayBuffer();
                const decoder = new LazPerf.LASDecoder(lazBuffer);
                const decompressedBuffer = decoder.getDecompressedData();
                
                const decompressedBlob = new Blob([decompressedBuffer], { type: 'application/octet-stream' });
                processedFile = new File([decompressedBlob], file.name.replace('.laz', '.las'), { type: 'application/octet-stream' });
                
                console.log(`âœ… LAZ fails dekompresÄ“ts: ${file.name} â†’ ${(decompressedBuffer.byteLength/1024/1024).toFixed(1)}MB`);
              } else {
                throw new Error('LAZ dekompresijas bibliotÄ“ka nav pieejama');
              }
            } catch (lazError) {
              console.warn(`âš ï¸ LAZ dekompresija neizdevÄs: ${lazError.message}`);
              console.warn(`ğŸ“‹ MÄ“Ä£inÄm lasÄ«t LAZ failu kÄ nesaspiesto LAS failu...`);
              console.warn(`   DaÅ¾reiz LAZ faili var bÅ«t daÄ¼Ä“ji nesaspiesti vai izmantot savietojamu formÄtu.`);
              // TurpinÄm ar oriÄ£inÄlo failu - daÅ¾reiz LAZ faili ir savietojami
            }
          }
          
          // NolasÄm LAS header (izmantojam processedFile)
          const headerBlob = processedFile.slice(0, 375);
          const headerBuffer = await headerBlob.arrayBuffer();
          const dv = new DataView(headerBuffer);
          
          const signature = String.fromCharCode(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3));
          if (signature !== "LASF") {
            throw new Error(`Fails ${file.name} nav LAS fails!`);
          }
          
          const pointDataOffset = dv.getUint32(96, true);
          const numberOfPoints = dv.getUint32(107, true);
          const pointDataFormat = dv.getUint8(104);
          const pointRecordLen = dv.getUint16(105, true);
          
          const xScale = dv.getFloat64(131, true);
          const yScale = dv.getFloat64(139, true); 
          const zScale = dv.getFloat64(147, true);
          const xOffset = dv.getFloat64(155, true);
          const yOffset = dv.getFloat64(163, true);
          const zOffset = dv.getFloat64(171, true);
          
          console.log(`LAS ${fileIndex}: ${numberOfPoints} punkti, formÄts ${pointDataFormat}`);
          
          const points = [];
          let hasUnclassifiedWarning = false;
          
          // AdaptÄ«vs LAS chunk izmÄ“rs
          let lasChunkSize;
          switch(systemSpecs.systemClass) {
            case 'high-end':
              lasChunkSize = Math.min(200000, Math.floor(numberOfPoints / (cpuCores / 2)));
              break;
            case 'high':
              lasChunkSize = Math.min(150000, Math.floor(numberOfPoints / cpuCores));
              break;
            case 'medium':
              lasChunkSize = Math.min(100000, Math.floor(numberOfPoints / cpuCores));
              break;
            case 'low':
              lasChunkSize = Math.min(50000, Math.floor(numberOfPoints / cpuCores));
              break;
            default:
              lasChunkSize = Math.min(50000, Math.floor(numberOfPoints / cpuCores));
          }
          
          const chunkSize = Math.max(10000, lasChunkSize);
          console.log(`ğŸ“¦ LAS ${fileIndex} chunk: ${chunkSize} punkti`);
          
          // Vispirms analizÄ“jam klasifikÄcijas (pirmais chunk)
          let fileIsClassified = true; // PieÅ†emam, ka ir klasificÄ“ts
          if (numberOfPoints > 0) {
            const analysisChunkSize = Math.min(50000, numberOfPoints); // AnalizÄ“jam lÄ«dz 50k punktiem
            const byteStart = pointDataOffset;
            const byteLen = analysisChunkSize * pointRecordLen;
            
            const analysisBlob = processedFile.slice(byteStart, byteStart + byteLen);
            const analysisBuffer = await analysisBlob.arrayBuffer();
            const analysisView = new DataView(analysisBuffer);
            
            let classificationCounts = {};
            let offset = 0;
            const classOffset = pointDataFormat >= 6 ? 17 : 15;
            
            // AnalizÄ“jam klasifikÄcijas
            for (let i = 0; i < analysisChunkSize; i++) {
              const classification = analysisView.getUint8(offset + classOffset) & 0x1F;
              classificationCounts[classification] = (classificationCounts[classification] || 0) + 1;
              offset += pointRecordLen;
            }
            
            console.log(`ğŸ” LAS ${fileIndex} klasifikÄciju analÄ«ze:`, classificationCounts);
            
            // Noteikam, vai fails ir klasificÄ“ts
            const totalAnalyzed = analysisChunkSize;
            const groundPoints = classificationCounts[2] || 0;
            const waterPoints = classificationCounts[8] || 0;
            const actualWaterPoints = classificationCounts[9] || 0;
            const buildingPoints = classificationCounts[6] || 0;
            const vegetationPoints = (classificationCounts[3] || 0) + (classificationCounts[4] || 0) + (classificationCounts[5] || 0);
            const unclassifiedCount = (classificationCounts[0] || 0) + (classificationCounts[1] || 0);
            
            const classifiedPoints = groundPoints + waterPoints + actualWaterPoints + buildingPoints + vegetationPoints;
            const classifiedPercent = (classifiedPoints / totalAnalyzed * 100).toFixed(1);
            const unclassifiedPercent = (unclassifiedCount / totalAnalyzed * 100).toFixed(1);
            
            console.log(`ğŸ“Š LAS ${fileIndex} klasifikÄcija: ${classifiedPercent}% klasificÄ“ti, ${unclassifiedPercent}% neklasificÄ“ti`);
            console.log(`   Ground(2): ${groundPoints}, Water(8): ${waterPoints}, ActualWater(9): ${actualWaterPoints}, Buildings(6): ${buildingPoints}, Vegetation(3-5): ${vegetationPoints}`);
            
            // Fails ir neklasificÄ“ts, ja ir maz klasificÄ“tu punktu UN daudz neklasificÄ“tu
            fileIsClassified = !((classifiedPoints / totalAnalyzed < 0.10) && (unclassifiedCount / totalAnalyzed > 0.80));
            
            if (!fileIsClassified) {
              const warningMessage = `âš ï¸ LAS failÄ ${fileIndex} (${file.name}) atrasti galvenokÄrt neklasificÄ“ti punkti - tiks izmantoti VISI punkti.`;
              console.warn(warningMessage);
              hasUnclassifiedWarning = true;
            } else {
              console.log(`âœ… LAS ${fileIndex} ir klasificÄ“ts - tiks izmantoti tikai ZEMES punkti (klase 2)`);
            }
          }
          
          for (let start = 0; start < numberOfPoints; start += chunkSize) {
            const end = Math.min(start + chunkSize, numberOfPoints);
            const count = end - start;
            
            const progress = ((start / numberOfPoints) * 100).toFixed(1);
            document.getElementById('status').textContent = `âš¡ LAS ${fileIndex}/${totalFiles}: ${start}-${end} no ${numberOfPoints} (${progress}%)`;
            
            // NolasÄm chunk
            const byteStart = pointDataOffset + start * pointRecordLen;
            const byteLen = count * pointRecordLen;
            
            const chunkBlob = processedFile.slice(byteStart, byteStart + byteLen);
            const chunkBuffer = await chunkBlob.arrayBuffer();
            const chunkView = new DataView(chunkBuffer);
            
            // ApstrÄdÄjam punktus
            let offset = 0;
            let classificationCounts = {};
            let debugCount = 0;
            
            for (let i = 0; i < count; i++) {
              const xInt = chunkView.getInt32(offset, true);
              const yInt = chunkView.getInt32(offset + 4, true);
              const zInt = chunkView.getInt32(offset + 8, true);
              
              const classOffset = pointDataFormat >= 6 ? 17 : 15;
              const classification = chunkView.getUint8(offset + classOffset) & 0x1F;
              
              // Debug: saskaitÄm klasifikÄcijas
              if (!classificationCounts[classification]) {
                classificationCounts[classification] = 0;
              }
              classificationCounts[classification]++;
              
              // Debug: parÄdÄm pirmos 10 punktus
              if (debugCount < 10 && start === 0) {
                console.log(`ğŸ” LAS ${fileIndex} punkts ${debugCount + 1}: klasifikÄcija=${classification}, formÄts=${pointDataFormat}, offset=${classOffset}`);
                debugCount++;
              }
              
              // Ja fails ir klasificÄ“ts, Å†emam tikai zemes punktus (2)
              // Ja nav klasificÄ“ts, Å†emam visus punktus
              const isGround = (classification === 2);
              const shouldIncludePoint = fileIsClassified ? isGround : true;
              
              if (shouldIncludePoint) {
                const x = xInt * xScale + xOffset;
                const y = yInt * yScale + yOffset;
                const z = zInt * zScale + zOffset;
                
                points.push({
                  x: x,
                  y: y,
                  z: z
                });
              }
              
              offset += pointRecordLen;
            }
            
            // Veco klasifikÄcijas analÄ«zi noÅ†Ä“mÄm - tagad notiek faila sÄkumÄ
            
            // AtmiÅ†as tÄ«rÄ«Å¡ana
            if (start % (chunkSize * 5) === 0) {
              if (typeof gc !== 'undefined') gc();
              await new Promise(resolve => setTimeout(resolve, 10));
            } else {
              await new Promise(resolve => setTimeout(resolve, 1));
            }
          }
          
          console.log(`âœ… LAS ${fileIndex} pabeigts! ${points.length} punkti`);
          resolve({
            points: points,
            hasUnclassifiedWarning: hasUnclassifiedWarning
          });
          
        } catch (error) {
          console.error(`KÄ¼Å«da LAS faila ${file.name} apstrÄdÄ“:`, error);
          reject(error);
        }
      });
    }

    async function readLAS(file) {
      return new Promise(async (resolve, reject) => {
        try {
          console.log(`LAS: ${file.name}, ${(file.size/1024/1024).toFixed(1)}MB`);
          
          // NolasÄm LAS header
          const headerBlob = file.slice(0, 375);
          const headerBuffer = await headerBlob.arrayBuffer();
          const dv = new DataView(headerBuffer);
          
          const signature = String.fromCharCode(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3));
          if (signature !== "LASF") {
            throw new Error("Nav LAS fails!");
          }
          
          const pointDataOffset = dv.getUint32(96, true);
          const numberOfPoints = dv.getUint32(107, true);
          const pointDataFormat = dv.getUint8(104);
          const pointRecordLen = dv.getUint16(105, true);
          
          const xScale = dv.getFloat64(131, true);
          const yScale = dv.getFloat64(139, true); 
          const zScale = dv.getFloat64(147, true);
          const xOffset = dv.getFloat64(155, true);
          const yOffset = dv.getFloat64(163, true);
          const zOffset = dv.getFloat64(171, true);
          
          console.log(`LAS: ${numberOfPoints} punkti, formÄts ${pointDataFormat}`);
          
            const points = [];
          
          // AdaptÄ«vs LAS chunk izmÄ“rs atkarÄ«bÄ no sistÄ“mas klases
          let lasChunkSize;
          switch(systemSpecs.systemClass) {
            case 'high-end':
              lasChunkSize = Math.min(200000, Math.floor(numberOfPoints / (cpuCores / 2))); // MaksimÄli lieli
              break;
            case 'high':
              lasChunkSize = Math.min(150000, Math.floor(numberOfPoints / cpuCores)); // Lieli
              break;
            case 'medium':
              lasChunkSize = Math.min(100000, Math.floor(numberOfPoints / cpuCores)); // VidÄ“ji
              break;
            case 'low':
              lasChunkSize = Math.min(50000, Math.floor(numberOfPoints / cpuCores)); // Mazi
              break;
            default:
              lasChunkSize = Math.min(50000, Math.floor(numberOfPoints / cpuCores));
          }
          
          const chunkSize = Math.max(10000, lasChunkSize); // Minimums 10k
          console.log(`ğŸ“¦ LAS ${systemSpecs.systemClass.toUpperCase()} chunk: ${chunkSize} punkti (${numberOfPoints} kopÄ, ${cpuCores} kodoli)`);
          
          for (let start = 0; start < numberOfPoints; start += chunkSize) {
            const end = Math.min(start + chunkSize, numberOfPoints);
            const count = end - start;
            
            const progress = ((start / numberOfPoints) * 100).toFixed(1);
            document.getElementById('status').textContent = `âš¡ LAS apstrÄde: ${start}-${end} no ${numberOfPoints} (${progress}%)`;
            
            // NolasÄm chunk
            const byteStart = pointDataOffset + start * pointRecordLen;
            const byteLen = count * pointRecordLen;
            
            const chunkBlob = processedFile.slice(byteStart, byteStart + byteLen);
            const chunkBuffer = await chunkBlob.arrayBuffer();
            const chunkView = new DataView(chunkBuffer);
            
            // ApstrÄdÄjam punktus
            let offset = 0;
            for (let i = 0; i < count; i++) {
              const xInt = chunkView.getInt32(offset, true);
              const yInt = chunkView.getInt32(offset + 4, true);
              const zInt = chunkView.getInt32(offset + 8, true);
              
              const classOffset = pointDataFormat >= 6 ? 17 : 15;
              const classification = chunkView.getUint8(offset + classOffset) & 0x1F;
              
              if (classification === 2) { // Ground points
                const x = xInt * xScale + xOffset;
                const y = yInt * yScale + yOffset;
                const z = zInt * zScale + zOffset;
                
                  points.push({
                    x: x,
                    y: y,
                  z: z
                });
              }
              
              offset += pointRecordLen;
            }
            
            // AtmiÅ†as tÄ«rÄ«Å¡ana un pauze
            if (start % (chunkSize * 5) === 0) {
              // TÄ«rÄm cache ik pa 5 chunks
              if (typeof gc !== 'undefined') gc(); // Ja pieejams
              await new Promise(resolve => setTimeout(resolve, 10)); // IlgÄka pauze
                  } else {
              await new Promise(resolve => setTimeout(resolve, 1));
            }
          }
          
          console.log(`âœ… Pabeigts! ${points.length} punkti`);
          
          // AprÄ“Ä·inÄm LAS punktu robeÅ¾as
          const bounds = calculateLASBounds(points);
          console.log(`ğŸ“ LAS robeÅ¾as:`, bounds);
            
            csvData = points;
          csvData.bounds = bounds; // Pievienojam robeÅ¾as
            resolve();
            
          } catch (error) {
          console.error('KÄ¼Å«da LAS faila apstrÄdÄ“:', error);
            reject(error);
          }
      });
    }

    let geoTiffImage = null; // GlabÄjam GeoTIFF image objektu streaming lasÄ«Å¡anai
    
    async function readGeoTIFF(file, lasBounds = null) {
      try {
        const fileSizeMB = file.size / 1024 / 1024;
        console.log(`GeoTIFF: ${file.name}, ${fileSizeMB.toFixed(1)}MB`);
        
        // Vispirms nolasÄm GeoTIFF metadata
        const tiff = await GeoTIFF.fromBlob(file);
        const image = await tiff.getImage();
        geoTiffImage = image;
        
        imageWidth = image.getWidth();
        imageHeight = image.getHeight();
        tiePoint = image.getTiePoints()[0];
        pixelScale = image.getFileDirectory().ModelPixelScale;
        
        if (!tiePoint || !pixelScale) {
          throw new Error("GeoTIFF failam trÅ«kst Ä£eoreferences informÄcijas!");
        }
        
        geoTransform = {
          tiePointX: tiePoint.x,
          tiePointY: tiePoint.y,
          scaleX: pixelScale[0],
          scaleY: pixelScale[1]
        };
        
        // AprÄ“Ä·inÄm GeoTIFF pilnÄs robeÅ¾as
        const geoTiffBounds = {
          minX: geoTransform.tiePointX,
          maxX: geoTransform.tiePointX + (imageWidth * geoTransform.scaleX),
          maxY: geoTransform.tiePointY,
          minY: geoTransform.tiePointY - (imageHeight * geoTransform.scaleY)
        };
        
        console.log(`ğŸ“Š GeoTIFF pilnÄs robeÅ¾as:`, geoTiffBounds);
        
        // Ja ir LAS robeÅ¾as, pÄrbaudam pÄrklÄjumu
        if (lasBounds) {
          console.log(`ğŸ” Ir LAS robeÅ¾as - sÄkam optimizÄciju`);
          const overlap = checkOverlap(lasBounds, geoTiffBounds);
          if (!overlap.hasOverlap) {
            throw new Error(`âŒ Nav pÄrklÄjuma! LAS: [${lasBounds.minX.toFixed(0)}, ${lasBounds.minY.toFixed(0)}] - GeoTIFF: [${geoTiffBounds.minX.toFixed(0)}, ${geoTiffBounds.minY.toFixed(0)}]`);
          }
          
          console.log(`âœ… PÄrklÄjums atrasts: ${overlap.overlapPercent.toFixed(1)}%`);
          console.log(`ğŸ¯ SÄk optimÄlÄ reÄ£iona ielÄdi...`);
          console.log(`ğŸ“Š Intersection reÄ£ions:`, overlap.intersection);
          
          // IelÄdÄ“jam tikai nepiecieÅ¡amo reÄ£ionu
          return await loadOptimalRegion(image, overlap.intersection);
        } else {
          console.log(`âŒ Nav LAS robeÅ¾u - izmantojam standarta reÅ¾Ä«mu`);
        }
        
        // AGRESÄªVA STRATÄ’Ä¢IJA: MÄ“Ä£inÄm ielÄdÄ“t pilnu failu neatkarÄ«gi no izmÄ“ra
        console.log(`ğŸ”¥ AGRESÄªVÄ€ STRATÄ’Ä¢IJA: MÄ“Ä£inÄm ielÄdÄ“t pilnu ${fileSizeMB.toFixed(1)}MB failu atmiÅ†Ä`);
        
        try {
          logMemoryUsage('Pirms pilnÄ faila ielÄdes:');
          
          // PÄrbaudam vai fails nav pÄrÄk liels
          const estimatedMemoryMB = (imageWidth * imageHeight * 4) / 1024 / 1024;
          const memoryInfo = getMemoryInfo();
          const availableMemoryMB = memoryInfo ? memoryInfo.available / 1024 / 1024 : 1000;
          
          console.log(`ğŸ“Š Faila izmÄ“rs: ${fileSizeMB.toFixed(1)}MB, novÄ“rtÄ“tÄ atmiÅ†a: ${estimatedMemoryMB.toFixed(1)}MB, pieejamÄ: ${availableMemoryMB.toFixed(1)}MB`);
          
          if (estimatedMemoryMB > availableMemoryMB * 0.8) {
            console.warn(`âš ï¸ Fails pÄrÄk liels atmiÅ†ai - uzreiz izmantojam streaming`);
            throw new Error("Fails pÄrÄk liels - streaming reÅ¾Ä«ms");
          }
          
          const rasterData = await image.readRasters();
          tiffArray = rasterData[0];
          logMemoryUsage('PÄ“c pilnÄ faila ielÄdes:');
          console.log(`âœ… AGRESÄªVS SUCCESS! Pilns fails ielÄdÄ“ts: ${fileSizeMB.toFixed(1)}MB, ${(tiffArray.length * 4 / 1024 / 1024).toFixed(1)}MB RAM`);
        } catch (fullFileError) {
          console.warn(`âš ï¸ PilnÄ faila ielÄde neizdevÄs: ${fullFileError.message}`);
          console.log(`ğŸ”„ Fallback: Streaming reÅ¾Ä«ms lielam failam`);
          tiffArray = null;
          console.log('âœ… GeoTIFF gatavs (streaming reÅ¾Ä«ms)');
          
          // PÄrbaudÄm vai geoTiffImage ir pieejams streaming reÅ¾Ä«mam
          if (!geoTiffImage) {
            console.error('âŒ Streaming reÅ¾Ä«ms nav pieejams - nav geoTiffImage!');
            throw new Error('GeoTIFF ielÄde pilnÄ«bÄ neizdevÄs');
          }
        }
        
      } catch (error) {
        console.error('KÄ¼Å«da GeoTIFF apstrÄdÄ“:', error);
        throw error;
      }
    }
    
    async function readGeoTIFFStreaming(file) {
      try {
        // Izmantojam File objektu tieÅ¡i streaming lasÄ«Å¡anai
        const tiff = await GeoTIFF.fromBlob(file);
      const image = await tiff.getImage();
        geoTiffImage = image;
        
      imageWidth = image.getWidth();
      imageHeight = image.getHeight();
      tiePoint = image.getTiePoints()[0];
      pixelScale = image.getFileDirectory().ModelPixelScale;
        
        if (!tiePoint || !pixelScale) {
          throw new Error("GeoTIFF failam trÅ«kst Ä£eoreferences informÄcijas!");
        }
        
        // NEielÄdÄ“jam visu atmiÅ†Ä - izmantojam streaming
        tiffArray = null;
        
      geoTransform = {
        tiePointX: tiePoint.x,
        tiePointY: tiePoint.y,
        scaleX: pixelScale[0],
        scaleY: pixelScale[1]
      };
      
        console.log('âœ… GeoTIFF gatavs (streaming reÅ¾Ä«ms)');
        
      } catch (error) {
        console.error('KÄ¼Å«da GeoTIFF streaming apstrÄdÄ“:', error);
        throw error;
      }
    }
    
    async function readMultipleGeoTIFF(files, lasBounds = null) {
      console.log(`ğŸ—‚ï¸ SÄk vairÄku GeoTIFF failu apstrÄdi: ${files.length} faili`);
      
      let totalSizeMB = 0;
      for (let i = 0; i < files.length; i++) {
        totalSizeMB += files[i].size / 1024 / 1024;
      }
      console.log(`ğŸ“Š KopÄ“jais izmÄ“rs: ${totalSizeMB.toFixed(1)}MB`);
      
      // ApstrÄdÄjam failus secÄ«gi (lai izvairÄ«tos no atmiÅ†as problÄ“mÄm)
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        console.log(`ğŸ“ ApstrÄdÄ failu ${i + 1}/${files.length}: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
        
        if (i === 0) {
          // Pirmais fails - pilna apstrÄde
          await readGeoTIFF(file, lasBounds);
        } else {
          // Papildu faili - pievienojam kÄ papildu slÄÅ†us vai apvienojam
          await readGeoTIFFAdditional(file, lasBounds, i);
        }
        
        logMemoryUsage(`PÄ“c faila ${i + 1}:`);
      }
      
      console.log(`âœ… Visi GeoTIFF faili apstrÄdÄti! KopÄ: ${files.length} faili`);
    }
    
    async function readGeoTIFFAdditional(file, lasBounds = null, index = 0) {
      try {
        const fileSizeMB = file.size / 1024 / 1024;
        console.log(`GeoTIFF ${index + 1}: ${file.name}, ${fileSizeMB.toFixed(1)}MB`);
        
        // NolasÄm papildu GeoTIFF metadata
        const tiff = await GeoTIFF.fromBlob(file);
        const image = await tiff.getImage();
        
        // SaglabÄjam papildu attÄ“lu atsaucei (var bÅ«t vajadzÄ«gs vÄ“lÄk)
        if (!window.additionalGeoTiffImages) {
          window.additionalGeoTiffImages = [];
        }
        window.additionalGeoTiffImages[index] = image;
        
        console.log(`âœ… Papildu GeoTIFF ${index + 1} ielÄdÄ“ts (metadati)`);
        
      } catch (error) {
        console.error(`KÄ¼Å«da papildu GeoTIFF ${index + 1} apstrÄdÄ“:`, error);
        throw error;
      }
    }

    // Cache GeoTIFF reÄ£ioniem, lai samazinÄtu disk I/O
    const geoTiffCache = new Map();
    
    // AdaptÄ«vs cache bloka izmÄ“rs atkarÄ«bÄ no sistÄ“mas klases
    function getCacheSize() {
      const memory = getMemoryInfo();
      
      switch(systemSpecs.systemClass) {
        case 'high-end':
          return 2048; // SUPER AGRESÄªVS CACHE - 2K bloki!
        case 'high':
          return 1536; // 1.5K bloki
        case 'medium':
          return 1024; // 1K bloki  
        case 'low':
          return 512;  // 512px bloki
        default:
          return memory && memory.available > 2000000000 ? 512 : 256;
      }
    }
    
    // SUPER OPTIMIZÄ€CIJA: Batch lasÄ«Å¡ana vairÄkiem punktiem vienlaicÄ«gi
    async function sampleBatchFromGeoTIFF(coordsArray) {
      if (!coordsArray || coordsArray.length === 0) return [];
      
      const results = new Array(coordsArray.length);
      
      // Ja tiffArray ir ielÄdÄ“ts, izmantojam to (ÄtrÄkais)
      if (tiffArray) {
        for (let i = 0; i < coordsArray.length; i++) {
          const coord = coordsArray[i];
          const pixelX = Math.floor((coord.x - geoTransform.tiePointX) / geoTransform.scaleX);
          const pixelY = Math.floor((geoTransform.tiePointY - coord.y) / geoTransform.scaleY);
          
          if (pixelX < 0 || pixelX >= imageWidth || pixelY < 0 || pixelY >= imageHeight) {
            results[i] = null;
            continue;
          }
          
          let pixelIndex;
          if (tiffArray.regionInfo) {
            const regionPixelX = pixelX - tiffArray.regionInfo.offsetX;
            const regionPixelY = pixelY - tiffArray.regionInfo.offsetY;
            
            if (regionPixelX < 0 || regionPixelX >= tiffArray.regionInfo.width ||
                regionPixelY < 0 || regionPixelY >= tiffArray.regionInfo.height) {
              results[i] = null;
              continue;
            }
            
            pixelIndex = regionPixelY * tiffArray.regionInfo.width + regionPixelX;
          } else {
            pixelIndex = pixelY * imageWidth + pixelX;
          }
          
          const tiffValue = tiffArray[pixelIndex];
          results[i] = (tiffValue === -9999.00 || tiffValue === null || isNaN(tiffValue)) ? null : tiffValue;
        }
        return results;
      }
      
      // Streaming reÅ¾Ä«ms ar SUPER BATCH optimizÄciju
      if (geoTiffImage) {
        // GrupÄ“jam punktus pÄ“c cache bloku reÄ£ioniem
        const regionGroups = new Map();
        const cacheSize = getCacheSize();
        
        for (let i = 0; i < coordsArray.length; i++) {
          const coord = coordsArray[i];
          const pixelX = Math.floor((coord.x - geoTransform.tiePointX) / geoTransform.scaleX);
          const pixelY = Math.floor((geoTransform.tiePointY - coord.y) / geoTransform.scaleY);
          
          if (pixelX < 0 || pixelX >= imageWidth || pixelY < 0 || pixelY >= imageHeight) {
            results[i] = null;
            continue;
          }
          
          // AprÄ“Ä·inÄm cache reÄ£ionu
          const regionX = Math.floor(pixelX / cacheSize) * cacheSize;
          const regionY = Math.floor(pixelY / cacheSize) * cacheSize;
          const regionKey = `${regionX}_${regionY}`;
          
          if (!regionGroups.has(regionKey)) {
            regionGroups.set(regionKey, []);
          }
          regionGroups.get(regionKey).push({ index: i, pixelX, pixelY, regionX, regionY });
        }
        
        // ParalÄ“li ielÄdÄ“jam visus nepiecieÅ¡amos reÄ£ionus
        const regionPromises = Array.from(regionGroups.entries()).map(async ([regionKey, points]) => {
          const { regionX, regionY } = points[0];
          
          // PÄrbaudam cache
          if (geoTiffCache.has(regionKey)) {
            const cachedData = geoTiffCache.get(regionKey);
            return { regionKey, data: cachedData, points };
          }
          
          // IelÄdÄ“jam jaunu reÄ£ionu
          try {
            const regionWidth = Math.min(cacheSize, imageWidth - regionX);
            const regionHeight = Math.min(cacheSize, imageHeight - regionY);
            
            let window = [regionX, regionY, regionX + regionWidth, regionY + regionHeight];
            
            // PielÄgojam reÄ£iona robeÅ¾Äm, ja nepiecieÅ¡ams
            if (geoTiffImage.regionInfo) {
              const { offsetX, offsetY, width, height } = geoTiffImage.regionInfo;
              if (regionX < offsetX || regionY < offsetY || 
                  regionX >= offsetX + width || regionY >= offsetY + height) {
                return { regionKey, data: null, points };
              }
              
              window = [
                Math.max(regionX, offsetX),
                Math.max(regionY, offsetY),
                Math.min(regionX + regionWidth, offsetX + width),
                Math.min(regionY + regionHeight, offsetY + height)
              ];
            }
            
            const regionData = await geoTiffImage.readRasters({ window });
            const data = regionData[0];
            
            // SaglabÄjam cache
            geoTiffCache.set(regionKey, data);
            
            return { regionKey, data, points };
          } catch (error) {
            console.warn(`KÄ¼Å«da reÄ£iona ${regionKey} ielÄdÄ“:`, error);
            return { regionKey, data: null, points };
          }
        });
        
        // GaidÄm visus reÄ£ionus
        const regionResults = await Promise.all(regionPromises);
        
        // ApstrÄdÄjam rezultÄtus
        for (const { regionKey, data, points } of regionResults) {
          if (!data) {
            points.forEach(point => results[point.index] = null);
            continue;
          }
          
          const cacheSize = getCacheSize();
          for (const point of points) {
            const localX = point.pixelX - point.regionX;
            const localY = point.pixelY - point.regionY;
            const localIndex = localY * cacheSize + localX;
            
            if (localIndex >= 0 && localIndex < data.length) {
              const tiffValue = data[localIndex];
              results[point.index] = (tiffValue === -9999.00 || tiffValue === null || isNaN(tiffValue)) ? null : tiffValue;
            } else {
              results[point.index] = null;
            }
          }
        }
        
        return results;
      }
      
      // Fallback - ja nav ne tiffArray, ne geoTiffImage
      return new Array(coordsArray.length).fill(null);
    }
    
    async function sampleValueFromGeoTIFF(coordX, coordY) {
      const pixelX = Math.floor((coordX - geoTransform.tiePointX) / geoTransform.scaleX);
      const pixelY = Math.floor((geoTransform.tiePointY - coordY) / geoTransform.scaleY);
      
      if (pixelX < 0 || pixelX >= imageWidth || pixelY < 0 || pixelY >= imageHeight) {
        return null;
      }
      
      // Ja tiffArray ir ielÄdÄ“ts, izmantojam to
      if (tiffArray) {
        let pixelIndex;
        
        // Ja ir reÄ£ionÄla ielÄde, pielÄgojam koordinÄtas
        if (tiffArray.regionInfo) {
          const regionPixelX = pixelX - tiffArray.regionInfo.offsetX;
          const regionPixelY = pixelY - tiffArray.regionInfo.offsetY;
          
          // PÄrbaudam, vai pikselis ir reÄ£iona robeÅ¾Äs
          if (regionPixelX < 0 || regionPixelX >= tiffArray.regionInfo.width ||
              regionPixelY < 0 || regionPixelY >= tiffArray.regionInfo.height) {
            return null; // Ä€rpus ielÄdÄ“tÄ reÄ£iona
          }
          
          pixelIndex = regionPixelY * tiffArray.regionInfo.width + regionPixelX;
        } else {
          // Pilna ielÄde
          pixelIndex = pixelY * imageWidth + pixelX;
        }
        
        const tiffValue = tiffArray[pixelIndex];
        if (tiffValue === -9999.00 || tiffValue === null || isNaN(tiffValue)) {
          return null;
        }
        return tiffValue;
      }
      
      // Streaming reÅ¾Ä«ms ar cache optimizÄciju un reÄ£iona pÄrbaudi
      if (geoTiffImage) {
        try {
          // Ja ir reÄ£iona robeÅ¾as, pÄrbaudam vai pikselis ir robeÅ¾Äs
          if (geoTiffImage.regionInfo) {
            const regionPixelX = pixelX - geoTiffImage.regionInfo.offsetX;
            const regionPixelY = pixelY - geoTiffImage.regionInfo.offsetY;
            
            if (regionPixelX < 0 || regionPixelX >= geoTiffImage.regionInfo.width ||
                regionPixelY < 0 || regionPixelY >= geoTiffImage.regionInfo.height) {
              return null; // Ä€rpus reÄ£iona
            }
            
            // PielÄgojam cache koordinÄtas reÄ£ionam
            const adjustedX = pixelX;
            const adjustedY = pixelY;
            
            // Noteicam cache reÄ£ionu ar dinamisko izmÄ“ru
            const dynamicCacheSize = getCacheSize();
            const regionX = Math.floor(adjustedX / dynamicCacheSize) * dynamicCacheSize;
            const regionY = Math.floor(adjustedY / dynamicCacheSize) * dynamicCacheSize;
            const cacheKey = `${regionX}_${regionY}`;
            
            // PÄrbaudam cache
            if (!geoTiffCache.has(cacheKey)) {
              // AprÄ“Ä·inÄm cache reÄ£iona robeÅ¾as
              const cacheMinX = Math.max(regionX, geoTiffImage.regionInfo.offsetX);
              const cacheMaxX = Math.min(regionX + dynamicCacheSize, geoTiffImage.regionInfo.offsetX + geoTiffImage.regionInfo.width);
              const cacheMinY = Math.max(regionY, geoTiffImage.regionInfo.offsetY);
              const cacheMaxY = Math.min(regionY + dynamicCacheSize, geoTiffImage.regionInfo.offsetY + geoTiffImage.regionInfo.height);
              
              if (cacheMinX >= cacheMaxX || cacheMinY >= cacheMaxY) {
                return null; // Cache reÄ£ions Ärpus mÅ«su reÄ£iona
              }
              
              const cacheWidth = cacheMaxX - cacheMinX;
              const cacheHeight = cacheMaxY - cacheMinY;
              const window = [cacheMinX, cacheMinY, cacheMaxX, cacheMaxY];
              
              const data = await geoTiffImage.readRasters({ window });
              geoTiffCache.set(cacheKey, {
                data: data[0],
                width: cacheWidth,
                height: cacheHeight,
                offsetX: cacheMinX,
                offsetY: cacheMinY
              });
              
              // AdaptÄ«vs cache izmÄ“rs atkarÄ«bÄ no sistÄ“mas klases
              const memoryStatus = logMemoryUsage('Cache:');
              let maxCacheSize = 20; // NoklusÄ“juma
              
              switch(systemSpecs.systemClass) {
                case 'high-end':
                  maxCacheSize = 500; // SUPER AGRESÄªVS CACHE - 500 reÄ£ioni!
                  console.log('ğŸ”¥ SUPER AGRESÄªVS CACHE (500 reÄ£ioni) - MAKSIMÄ€LA JAUDAS IZMANTOÅ ANA!');
                  break;
                case 'high':
                  maxCacheSize = 350; // 350 reÄ£ioni
                  console.log('ğŸ”¥ SUPER LIELS CACHE (350 reÄ£ioni) - AUGSTA VEIKTSPÄ’JA!');
                  break;
                case 'medium':
                  maxCacheSize = 200; // 200 reÄ£ioni
                  console.log('ğŸ”¥ LIELS CACHE (200 reÄ£ioni) - LABA VEIKTSPÄ’JA!');
                  break;
                case 'low':
                  maxCacheSize = 100; // 100 reÄ£ioni
                  console.log('ğŸ”¥ VIDÄ’JS CACHE (100 reÄ£ioni) - OPTIMIZÄ’TA VEIKTSPÄ’JA!');
                  break;
              }
              
              // AGRESÄªVA CACHE STRATÄ’Ä¢IJA: Nekad nesamazinÄm cache
              if (memoryStatus === 'low') {
                console.warn('âš ï¸ Zema atmiÅ†a, bet saglabÄjam lielu cache agresÄ«vai veiktspÄ“jai');
                // NesamazinÄm cache - lai saglabÄtu maksimÄlo Ätrumu
              }
              
              // TÄ«rÄm cache, ja pÄrÄk liels
              while (geoTiffCache.size > maxCacheSize) {
                const firstKey = geoTiffCache.keys().next().value;
                geoTiffCache.delete(firstKey);
              }
            }
      } else {
            // Standarta cache bez reÄ£iona ierobeÅ¾ojumiem ar dinamisko izmÄ“ru
            const dynamicCacheSize = getCacheSize();
            const regionX = Math.floor(pixelX / dynamicCacheSize) * dynamicCacheSize;
            const regionY = Math.floor(pixelY / dynamicCacheSize) * dynamicCacheSize;
            const cacheKey = `${regionX}_${regionY}`;
            
            if (!geoTiffCache.has(cacheKey)) {
              const regionWidth = Math.min(dynamicCacheSize, imageWidth - regionX);
              const regionHeight = Math.min(dynamicCacheSize, imageHeight - regionY);
              const window = [regionX, regionY, regionX + regionWidth, regionY + regionHeight];
              
              const data = await geoTiffImage.readRasters({ window });
              geoTiffCache.set(cacheKey, {
                data: data[0],
                width: regionWidth,
                height: regionHeight,
                offsetX: regionX,
                offsetY: regionY
              });
              
              if (geoTiffCache.size > 20) {
                const firstKey = geoTiffCache.keys().next().value;
                geoTiffCache.delete(firstKey);
              }
            }
          }
          
          // IegÅ«stam vÄ“rtÄ«bu no cache ar dinamisko izmÄ“ru
          const dynamicCacheSize = getCacheSize();
          const cacheKey = `${Math.floor(pixelX / dynamicCacheSize) * dynamicCacheSize}_${Math.floor(pixelY / dynamicCacheSize) * dynamicCacheSize}`;
          const cached = geoTiffCache.get(cacheKey);
          
          if (cached) {
            const localX = pixelX - cached.offsetX;
            const localY = pixelY - cached.offsetY;
            
            if (localX >= 0 && localX < cached.width && localY >= 0 && localY < cached.height) {
              const tiffValue = cached.data[localY * cached.width + localX];
              if (tiffValue === -9999.00 || tiffValue === null || isNaN(tiffValue)) {
        return null;
              }
              return tiffValue;
            }
          }
          
          return null;
        } catch (error) {
          console.warn(`KÄ¼Å«da piksela lasÄ«Å¡anÄ (${pixelX}, ${pixelY}):`, error);
          return null;
        }
      }
      
      return null;
    }

    // DetalizÄ“ta sistÄ“mas resursu noteikÅ¡ana
    function detectSystemSpecs() {
      const specs = {
        cpuCores: navigator.hardwareConcurrency || 8,
        memory: getMemoryInfo(),
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        deviceMemory: navigator.deviceMemory || null, // GB
        connection: navigator.connection || null
      };
      
      // AprÄ“Ä·inÄm sistÄ“mas klasi
      let systemClass = 'medium';
      if (specs.cpuCores >= 16 && specs.memory && specs.memory.limit > 4000000000) {
        systemClass = 'high-end';
      } else if (specs.cpuCores >= 8 && specs.memory && specs.memory.limit > 2000000000) {
        systemClass = 'high';
      } else if (specs.cpuCores <= 4 || (specs.memory && specs.memory.limit < 1000000000)) {
        systemClass = 'low';
      }
      
      specs.systemClass = systemClass;
      return specs;
    }
    
    const systemSpecs = detectSystemSpecs();
    
    // DetalizÄ“ts sistÄ“mas pÄrskats
    function displaySystemSummary() {
      console.log(`\nğŸ–¥ï¸ =================== SISTÄ’MAS ANALÄªZE ===================`);
      console.log(`ğŸš€ CPU kodoli: ${systemSpecs.cpuCores}`);
      console.log(`ğŸ’¾ AtmiÅ†as limits: ${systemSpecs.memory ? (systemSpecs.memory.limit/1024/1024/1024).toFixed(1) + 'GB' : 'Nav pieejams'}`);
      console.log(`ğŸ’¾ PieejamÄ atmiÅ†a: ${systemSpecs.memory ? (systemSpecs.memory.available/1024/1024/1024).toFixed(1) + 'GB' : 'Nav pieejams'}`);
      console.log(`ğŸ“Š SistÄ“mas klase: ${systemSpecs.systemClass.toUpperCase()}`);
      console.log(`ğŸŒ Platforma: ${systemSpecs.platform}`);
      if (systemSpecs.deviceMemory) {
        console.log(`ğŸ’½ IerÄ«ces RAM: ${systemSpecs.deviceMemory}GB`);
      }
      
      // OptimizÄcijas parametri
      console.log(`\nâš¡ ================= OPTIMIZÄ€CIJAS PARAMETRI =================`);
      const memory = getMemoryInfo();
      if (memory && memory.available > 1000000000) {
        let memoryPercent = 0.7;
        switch(systemSpecs.systemClass) {
          case 'high-end': memoryPercent = 0.85; break;
          case 'high': memoryPercent = 0.80; break;
          case 'medium': memoryPercent = 0.75; break;
          case 'low': memoryPercent = 0.60; break;
        }
        const maxPixels = Math.floor(memory.available * memoryPercent / 4);
        console.log(`ğŸ¯ MaksimÄlÄ atmiÅ†as izmantoÅ¡ana: ${(memoryPercent*100).toFixed(0)}%`);
        console.log(`ğŸ¯ MaksimÄlie pikseÄ¼i: ${(maxPixels/1000000).toFixed(0)}M (${(maxPixels*4/1024/1024).toFixed(0)}MB)`);
      }
      
      const cacheSize = getCacheSize();
      console.log(`ğŸ¯ Cache bloku izmÄ“rs: ${cacheSize}x${cacheSize} pikseÄ¼i`);
      console.log(`ğŸ¯ CPU kodolu izmantoÅ¡ana: ${systemSpecs.systemClass === 'high-end' ? '100%' : systemSpecs.systemClass === 'high' ? '80%' : systemSpecs.systemClass === 'medium' ? '60%' : '40%'}`);
      console.log(`\nğŸ”¥ ================= MAKSIMÄ€LÄ€S JAUDAS STRATÄ’Ä¢IJA =================`);
      console.log(`ğŸ§  GUDRA izvÄ“le starp atmiÅ†u un streaming`);
      console.log(`ğŸš€ NEKAD nesamazina cache izmÄ“ru`);
      console.log(`ğŸš€ AGRESÄªVS limits: 40% no pieejamÄs atmiÅ†as (2x vairÄk!)`);
      console.log(`ğŸš€ SUPER CACHE: LÄ«dz 500 reÄ£ioniem ar 2K bloku izmÄ“ru`);
      console.log(`ğŸš€ SUPER PARALÄ’LÄ€ APSTRÄ€DE: LÄ«dz 200% CPU izmantoÅ¡ana`);
      console.log(`ğŸš€ 2-lÄ«meÅ†u sistÄ“ma:`);
      console.log(`   1ï¸âƒ£ Maziem reÄ£ioniem (â‰¤40% RAM): AtmiÅ†Ä`);
      console.log(`   2ï¸âƒ£ Lieliem reÄ£ioniem (>40% RAM): SUPER STREAMING`);
      console.log(`ğŸš€ Pilnu failu ielÄde neatkarÄ«gi no izmÄ“ra`);
      console.log(`ğŸš€ Nav Array buffer allocation failed kÄ¼Å«du!`);
      console.log(`ğŸ¯ MÄ’RÄ¶IS: MAKSIMÄ€LA datora jaudas izmantoÅ¡ana!`);
      console.log(`================================================================\n`);
    }
    
    displaySystemSummary();
    const cpuCores = systemSpecs.cpuCores;
    
    // AtmiÅ†as monitorings un adaptÄ«va stratÄ“Ä£ija
    function getMemoryInfo() {
      if (performance.memory) {
        return {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit,
          available: performance.memory.jsHeapSizeLimit - performance.memory.usedJSHeapSize
        };
      }
      return null;
    }
    
    function logMemoryUsage(context = '') {
      const memory = getMemoryInfo();
      if (memory) {
        const usedMB = (memory.used / 1024 / 1024).toFixed(1);
        const availableMB = (memory.available / 1024 / 1024).toFixed(1);
        const limitMB = (memory.limit / 1024 / 1024).toFixed(1);
        console.log(`ğŸ’¾ ${context} AtmiÅ†a: ${usedMB}MB izmantots, ${availableMB}MB pieejams, ${limitMB}MB limits`);
        
        // BrÄ«dinÄjums, ja atmiÅ†a tuvojas limitam
        if (memory.available < memory.limit * 0.2) { // MazÄk par 20% pieejams
          console.warn(`âš ï¸ Zema atmiÅ†a! Tikai ${availableMB}MB pieejams`);
          return 'low';
        }
        return 'ok';
      }
      return 'unknown';
    }
    
    // Funkcija punktu robeÅ¾u aprÄ“Ä·inÄÅ¡anai (universÄla)
    function calculateBounds(points, isCSV = false) {
      if (!points || points.length === 0) return null;
      
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      points.forEach(point => {
        const x = isCSV ? parseFloat(point.x) : point.x;
        const y = isCSV ? parseFloat(point.y) : point.y;
        
        if (isNaN(x) || isNaN(y)) return;
        
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      });
      
      // Pievienojam 10m bufferi droÅ¡Ä«bai
      const buffer = 10;
      return {
        minX: minX - buffer,
        maxX: maxX + buffer,
        minY: minY - buffer,
        maxY: maxY + buffer,
        width: (maxX - minX) + (2 * buffer),
        height: (maxY - minY) + (2 * buffer)
      };
    }
    
    // LAS punktu robeÅ¾as
    function calculateLASBounds(points) {
      return calculateBounds(points, false);
    }
    
    // CSV punktu robeÅ¾as
    function calculateCSVBounds(points) {
      return calculateBounds(points, true);
    }
    
    // Funkcija pÄrklÄjuma pÄrbaudei
    function checkOverlap(lasBounds, geoTiffBounds) {
      const intersectionMinX = Math.max(lasBounds.minX, geoTiffBounds.minX);
      const intersectionMaxX = Math.min(lasBounds.maxX, geoTiffBounds.maxX);
      const intersectionMinY = Math.max(lasBounds.minY, geoTiffBounds.minY);
      const intersectionMaxY = Math.min(lasBounds.maxY, geoTiffBounds.maxY);
      
      const hasOverlap = (intersectionMinX < intersectionMaxX) && (intersectionMinY < intersectionMaxY);
      
      if (!hasOverlap) {
        return { hasOverlap: false, overlapPercent: 0 };
      }
      
      const intersectionArea = (intersectionMaxX - intersectionMinX) * (intersectionMaxY - intersectionMinY);
      const lasArea = lasBounds.width * lasBounds.height;
      const overlapPercent = (intersectionArea / lasArea) * 100;
      
      return {
        hasOverlap: true,
        overlapPercent,
        intersection: {
          minX: intersectionMinX,
          maxX: intersectionMaxX,
          minY: intersectionMinY,
          maxY: intersectionMaxY,
          width: intersectionMaxX - intersectionMinX,
          height: intersectionMaxY - intersectionMinY
        }
      };
    }
    
    // Funkcija optimÄlÄ GeoTIFF reÄ£iona ielÄdei ar atmiÅ†as pÄrbaudi
    async function loadOptimalRegion(image, region) {
      try {
        console.log(`ğŸ”§ loadOptimalRegion izsaukta ar reÄ£ionu:`, region);
        logMemoryUsage('loadOptimalRegion sÄkums:');
        // KonvertÄ“jam koordinÄtas uz pikseÄ¼iem
        const pixelMinX = Math.floor((region.minX - geoTransform.tiePointX) / geoTransform.scaleX);
        const pixelMaxX = Math.ceil((region.maxX - geoTransform.tiePointX) / geoTransform.scaleX);
        const pixelMinY = Math.floor((geoTransform.tiePointY - region.maxY) / geoTransform.scaleY);
        const pixelMaxY = Math.ceil((geoTransform.tiePointY - region.minY) / geoTransform.scaleY);
        
        // IerobeÅ¾ojam pikseÄ¼u robeÅ¾as
        const clippedMinX = Math.max(0, pixelMinX);
        const clippedMaxX = Math.min(imageWidth, pixelMaxX);
        const clippedMinY = Math.max(0, pixelMinY);
        const clippedMaxY = Math.min(imageHeight, pixelMaxY);
        
        const regionWidth = clippedMaxX - clippedMinX;
        const regionHeight = clippedMaxY - clippedMinY;
        const totalPixels = regionWidth * regionHeight;
        
        console.log(`ğŸ¯ ReÄ£ions: ${regionWidth}x${regionHeight} pikseÄ¼i (${(totalPixels / 1000000).toFixed(1)}M, ${((totalPixels) / (imageWidth * imageHeight) * 100).toFixed(1)}% no pilnÄ)`);
        
        // Dinamiska atmiÅ†as limita noteikÅ¡ana
        const memory = getMemoryInfo();
        let maxPixels = 100000000; // NoklusÄ“juma 100M pikseÄ¼i â‰ˆ 400MB RAM
        
        if (memory && memory.available > 1000000000) { // Ja > 1GB pieejams
          // AdaptÄ«vs atmiÅ†as izmantoÅ¡anas procents atkarÄ«bÄ no sistÄ“mas klases
          let memoryUsagePercent = 0.7; // NoklusÄ“juma 70%
          
          switch(systemSpecs.systemClass) {
            case 'high-end':
              memoryUsagePercent = 0.85; // 85% high-end sistÄ“mÄm
              break;
            case 'high':
              memoryUsagePercent = 0.80; // 80% augsta lÄ«meÅ†a sistÄ“mÄm
              break;
            case 'medium':
              memoryUsagePercent = 0.75; // 75% vidÄ“jÄm sistÄ“mÄm
              break;
            case 'low':
              memoryUsagePercent = 0.60; // 60% zemÄm sistÄ“mÄm
              break;
          }
          
          // Izmantojam adaptÄ«vo procentu no pieejamÄs atmiÅ†as (4 baiti uz pikseli)
          maxPixels = Math.floor(memory.available * memoryUsagePercent / 4);
          console.log(`ğŸš€ ${systemSpecs.systemClass.toUpperCase()} sistÄ“ma: ${(memoryUsagePercent*100).toFixed(0)}% atmiÅ†as`);
          console.log(`ğŸš€ Dinamiskais limits: ${(maxPixels/1000000).toFixed(0)}M pikseÄ¼i (${(maxPixels*4/1024/1024).toFixed(0)}MB) no ${(memory.available/1024/1024).toFixed(0)}MB pieejamÄs atmiÅ†as`);
        } else {
          console.log(`ğŸ“Š NoklusÄ“juma limits: ${(maxPixels/1000000).toFixed(0)}M pikseÄ¼i`);
        }
        
        // SUPER STREAMING STRATÄ’Ä¢IJA: Gudra izvÄ“le starp atmiÅ†u un streaming
        console.log(`ğŸ§  SUPER STREAMING: NovÄ“rtÄ“jam ${(totalPixels/1000000).toFixed(1)}M pikseÄ¼u reÄ£ionu`);
        console.log(`   NepiecieÅ¡amÄ atmiÅ†a: ${(totalPixels*4/1024/1024).toFixed(0)}MB`);
        console.log(`   PieejamÄ atmiÅ†a: ${(memory.available/1024/1024).toFixed(0)}MB`);
        console.log(`   DroÅ¡ais limits: ${(maxPixels/1000000).toFixed(1)}M pikseÄ¼i`);
        
        // SUPER AGRESÄªVS LIMITS - 40% no pieejamÄs atmiÅ†as (2x vairÄk!)
        const safeLimit = Math.floor(memory.available * 0.4 / 4); // 40% no pieejamÄs atmiÅ†as
        const shouldUseStreaming = totalPixels > safeLimit;
        
        if (shouldUseStreaming) {
          console.log(`ğŸš¨ Liels reÄ£ions (${(totalPixels/1000000).toFixed(1)}M > ${(safeLimit/1000000).toFixed(1)}M) - SUPER STREAMING ar maksimÄlu cache!`);
        } else {
          console.log(`âœ… Mazs reÄ£ions (${(totalPixels/1000000).toFixed(1)}M â‰¤ ${(safeLimit/1000000).toFixed(1)}M) - ielÄdÄ“jam atmiÅ†Ä`);
        }
        
        if (shouldUseStreaming) {
          // SUPER STREAMING - uzreiz bez atmiÅ†as mÄ“Ä£inÄjumiem
          console.log(`ğŸš€ SUPER STREAMING aktivizÄ“ts - bez atmiÅ†as ielÄdes mÄ“Ä£inÄjumiem`);
          
          geoTiffImage.regionInfo = {
            offsetX: clippedMinX,
            offsetY: clippedMinY,
            width: regionWidth,
            height: regionHeight
          };
          tiffArray = null;
          console.log(`âœ… SUPER STREAMING gatavs ${(totalPixels/1000000).toFixed(1)}M pikseÄ¼u apstrÄdei`);
          
        } else {
          // Tikai maziem reÄ£ioniem mÄ“Ä£inÄm ielÄdÄ“t atmiÅ†Ä
          try {
            console.log(`ğŸ’¾ Mazs reÄ£ions - mÄ“Ä£inÄm ielÄdÄ“t atmiÅ†Ä...`);
            logMemoryUsage('Pirms mazÄ reÄ£iona ielÄdes:');
            
            const window = [clippedMinX, clippedMinY, clippedMaxX, clippedMaxY];
            const regionData = await image.readRasters({ window });
            
            // SaglabÄjam reÄ£iona informÄciju
            tiffArray = regionData[0];
            tiffArray.regionInfo = {
              offsetX: clippedMinX,
              offsetY: clippedMinY,
              width: regionWidth,
              height: regionHeight
            };
            
            logMemoryUsage('PÄ“c mazÄ reÄ£iona ielÄdes:');
            console.log(`âœ… Mazs reÄ£ions ielÄdÄ“ts atmiÅ†Ä: ${(totalPixels / 1000000).toFixed(1)}M pikseÄ¼i, ${(tiffArray.length * 4 / 1024 / 1024).toFixed(1)}MB`);
            
          } catch (memoryError) {
            console.warn(`âš ï¸ Pat mazs reÄ£ions neizdevÄs: ${memoryError.message}`);
            console.log(`ğŸ”„ Fallback uz streaming pat mazam reÄ£ionam...`);
            
            // Fallback uz streaming
            geoTiffImage.regionInfo = {
              offsetX: clippedMinX,
              offsetY: clippedMinY,
              width: regionWidth,
              height: regionHeight
            };
            tiffArray = null;
            console.log(`âœ… Streaming aktivizÄ“ts pÄ“c neveiksmÄ«ga mazÄ reÄ£iona`);
          }
        }
        
      } catch (error) {
        console.error('KÄ¼Å«da optimÄlÄ reÄ£iona ielÄdÄ“:', error);
        throw error;
      }
    }
    
    async function createGeoJSON() {
      const features = [];
      let totalPoints = 0;
      let outsidePoints = 0;
      let validPoints = 0;
      
        // Initialize layers early so we can add points during processing
        if (!window.pointLayers) {
          window.pointLayers = {
            "Î”Z virs 1.0 m": L.layerGroup(),
            "Î”Z 0.5â€“1.0 m": L.layerGroup(),
            "Î”Z 0.2â€“0.5 m": L.layerGroup(),
            "Î”Z 0.1â€“0.2 m": L.layerGroup(),
            "Î”Z lÄ«dz 0.1 m": L.layerGroup(),
            "Î”Z -0.1â€“0 m": L.layerGroup(),
            "Î”Z -0.2â€“ -0.1 m": L.layerGroup(),
            "Î”Z -0.5â€“ -0.2 m": L.layerGroup(),
            "Î”Z -1.0â€“ -0.5 m": L.layerGroup(),
            "Î”Z zem -1.0 m": L.layerGroup()
          };
        }
        
        // IegÅ«stam lietotÄja izvÄ“lÄ“to sampling vÄ“rtÄ«bu
        const samplingSlider = document.getElementById('samplingSlider');
        const userSamplingPercent = parseInt(samplingSlider.value);
        const SAMPLING_RATE = userSamplingPercent / 100; // KonvertÄ“jam procentos uz decimÄldaÄ¼u
        const samplingInterval = userSamplingPercent === 0 ? 1 : Math.round(100 / userSamplingPercent); // Katrs N-tais punkts
        
        const layerCounters = {
          "Î”Z virs 1.0 m": 0,
          "Î”Z 0.5â€“1.0 m": 0,
          "Î”Z 0.2â€“0.5 m": 0,
          "Î”Z 0.1â€“0.2 m": 0,
          "Î”Z lÄ«dz 0.1 m": 0,
          "Î”Z -0.1â€“0 m": 0,
          "Î”Z -0.2â€“ -0.1 m": 0,
          "Î”Z -0.5â€“ -0.2 m": 0,
          "Î”Z -1.0â€“ -0.5 m": 0,
          "Î”Z zem -1.0 m": 0
        };
        
        if (userSamplingPercent === 0) {
          console.log(`ğŸ¯ Processing ${csvData.length} points - VISI punkti kartÄ“ (bez sampling)`);
        } else {
          console.log(`ğŸ¯ Processing ${csvData.length} points ar ${userSamplingPercent}% sampling (katrs ${samplingInterval}. punkts)`);
        }
      
      const startTime = performance.now();
      console.log(`ğŸš€ SÄk GeoJSON izveidi ar ${csvData.length} punktiem (${cpuCores} kodoli)...`);
      
      // MaksimÄli optimizÄ“ti chunks un batch izmÄ“ri atkarÄ«bÄ no sistÄ“mas klases
      const baseChunkSize = Math.max(1000, Math.floor(csvData.length / (cpuCores * 2))); // AgresÄ«vÄks sadalÄ«jums
      let maxChunkSize, batchSize, parallelWorkers;
      
      switch(systemSpecs.systemClass) {
        case 'high-end':
          maxChunkSize = 200000;  // SUPER AGRESÄªVS - 2x lielÄki chunks!
          batchSize = 1000;       // SUPER batch
          parallelWorkers = cpuCores * 2; // 2x VAIRÄ€K WORKER!
          console.log(`ğŸ”¥ SUPER HIGH-END optimizÄcija: ${maxChunkSize} chunk, ${batchSize} batch, ${parallelWorkers} workers (200% CPU!)`);
          break;
        case 'high':
          maxChunkSize = 150000;  // 1.5x lielÄki chunks
          batchSize = 750;        // 1.5x batch
          parallelWorkers = Math.floor(cpuCores * 1.5); // 1.5x worker
          console.log(`ğŸ”¥ SUPER HIGH optimizÄcija: ${maxChunkSize} chunk, ${batchSize} batch, ${parallelWorkers} workers (150% CPU!)`);
          break;
        case 'medium':
          maxChunkSize = 100000;  // Visi kodoli
          batchSize = 500;        // Liels batch
          parallelWorkers = cpuCores; // Visi kodoli
          console.log(`ğŸ”¥ SUPER MEDIUM optimizÄcija: ${maxChunkSize} chunk, ${batchSize} batch, ${parallelWorkers} workers (100% CPU!)`);
          break;
        case 'low':
          maxChunkSize = 50000;   // LielÄki chunks
          batchSize = 250;        // LielÄks batch
          parallelWorkers = Math.floor(cpuCores * 0.8); // 80% kodolu
          console.log(`ğŸ”¥ SUPER LOW optimizÄcija: ${maxChunkSize} chunk, ${batchSize} batch, ${parallelWorkers} workers (80% CPU!)`);
          break;
        default:
          maxChunkSize = 25000;
          batchSize = 100;
          parallelWorkers = Math.floor(cpuCores * 0.5);
      }
      
      const chunkSize = Math.min(baseChunkSize, maxChunkSize);
      batchSize = Math.min(batchSize, chunkSize); // Nevar bÅ«t lielÄks par chunk
      
      console.log(`ğŸ”¥ SUPER FINÄ€LAIS CHUNK: ${chunkSize} punkti, batch: ${batchSize} punkti, ${parallelWorkers}/${cpuCores} kodoli (${Math.round(parallelWorkers/cpuCores*100)}% CPU JAUDAS!)`);
      
      for (let i = 0; i < csvData.length; i += chunkSize) {
        const chunk = csvData.slice(i, Math.min(i + chunkSize, csvData.length));
        
        // AtjauninÄm statusu
        document.getElementById('status').textContent = `ğŸ”¥ ApstrÄdÄ ${i}-${Math.min(i + chunkSize, csvData.length)} no ${csvData.length} (${((i/csvData.length)*100).toFixed(1)}%)`;
        
        // ApstrÄdÄjam chunk pa batch grupÄm
        for (let j = 0; j < chunk.length; j += batchSize) {
          const batch = chunk.slice(j, Math.min(j + batchSize, chunk.length));
          
          // SUPER OPTIMIZÄ€CIJA: Batch apstrÄde ar koordinÄtu cache
          const batchCoords = batch.map(row => ({
            x: parseFloat(row.x),
            y: parseFloat(row.y),
            z: parseFloat(row.z),
            row: row
          })).filter(item => !isNaN(item.x) && !isNaN(item.y) && !isNaN(item.z));
          
          // Batch lasÄ«Å¡ana visiem punktiem vienlaicÄ«gi
          const tiffValues = await sampleBatchFromGeoTIFF(batchCoords);
          
          // SUPER PARALÄ’LÄ€ koordinÄtu transformÄcija
          const coordTransforms = batchCoords.map(item => 
            proj4("EPSG:3059", "EPSG:4326", [item.x, item.y])
          );
          
          // ParalÄ“li apstrÄdÄjam rezultÄtus (bez async - ÄtrÄk!)
          const batchPromises = batchCoords.map((item, index) => {
            const tiffZ = tiffValues[index];
            if (tiffZ === null || isNaN(tiffZ)) return null;
            
            const diffValue = item.z - tiffZ;
            const [lng, lat] = coordTransforms[index];
            
            return {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [lng, lat]
              },
              properties: {
                CSV_X: item.x,
                CSV_Y: item.y,
                CSV_Z: item.z,
                DEM_Z: tiffZ,
                difference: diffValue
              }
            };
          });
          
          // Nav vajadzÄ«gs Promise.all - rezultÄti jau ir gatavi!
          const batchResults = batchPromises;
          
          // Store ALL features - no sampling, but process them directly to layers
          batchResults.forEach((feature, index) => {
            totalPoints++;
            if (feature) {
              validPoints++;
              
              // Add ALL features to GeoJSON - no limits
        features.push(feature);
              
              // Determine layer category first
              const diff = feature.properties.difference;
              let pointCategory = "";
              if (diff >= 1.0) pointCategory = "Î”Z virs 1.0 m";
              else if (diff >= 0.5) pointCategory = "Î”Z 0.5â€“1.0 m";
              else if (diff >= 0.2) pointCategory = "Î”Z 0.2â€“0.5 m";
              else if (diff >= 0.1) pointCategory = "Î”Z 0.1â€“0.2 m";
              else if (diff >= 0) pointCategory = "Î”Z lÄ«dz 0.1 m";
              else if (diff >= -0.1) pointCategory = "Î”Z -0.1â€“0 m";
              else if (diff >= -0.2) pointCategory = "Î”Z -0.2â€“ -0.1 m";
              else if (diff >= -0.5) pointCategory = "Î”Z -0.5â€“ -0.2 m";
              else if (diff >= -1.0) pointCategory = "Î”Z -1.0â€“ -0.5 m";
              else pointCategory = "Î”Z zem -1.0 m";
              
              // Apply user-defined sampling per layer
              layerCounters[pointCategory]++;
              const shouldAddToMap = userSamplingPercent === 0 ? true : (layerCounters[pointCategory] % samplingInterval === 0);
              
              if (shouldAddToMap && window.pointLayers[pointCategory]) {
                const latlng = L.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
                
                // Create canvas marker with user-defined sampling
                const marker = L.circleMarker(latlng, {
                  renderer: canvasRenderer,
                  radius: 3, // Slightly bigger since fewer points
                  fillColor: getDiffColor(diff),
                  color: '#000',
                  weight: 0.5,
                  opacity: 0.8,
                  fillOpacity: 0.7
                }).bindPopup(`
                  CSV_Z: ${feature.properties.CSV_Z.toFixed(2)}<br>
                  DEM_Z: ${feature.properties.DEM_Z.toFixed(2)}<br>
                  Diff: ${diff.toFixed(2)}
                `);
                
                window.pointLayers[pointCategory].addLayer(marker);
              }
            } else {
              outsidePoints++;
            }
          });
        }
        
        // SUPER Ä€TRA apstrÄde - minimÄla pauze tikai UI atjaunoÅ¡anai
        if (i % (chunkSize * 10) === 0) { // Pauze tikai katru 10. chunk
          await new Promise(resolve => setTimeout(resolve, 0)); // Tikai UI thread atbrÄ«voÅ¡ana
        }
      }
      
      const endTime = performance.now();
      const processingTime = ((endTime - startTime) / 1000).toFixed(2);
      const pointsPerSecond = (validPoints / (processingTime || 1)).toFixed(0);
      
      console.log(`âœ… GeoJSON pabeigts: ${totalPoints} kopÄ, ${validPoints} derÄ«gi, ${outsidePoints} Ärpus robeÅ¾Äm`);
        console.log(`ğŸ“Š GeoJSON features: ${features.length} (eksportam)`);
        
        // Per-layer statistics with user-defined sampling
        let totalMappedPoints = 0;
        if (userSamplingPercent === 0) {
          console.log(`ğŸ“Š Visi punkti kartÄ“ (bez sampling):`);
          Object.keys(layerCounters).forEach(layerName => {
            const totalInLayer = layerCounters[layerName];
            totalMappedPoints += totalInLayer;
            if (totalInLayer > 0) {
              console.log(`   ${layerName}: ${totalInLayer} punkti`);
            }
          });
          console.log(`ğŸ¯ Total mapped points: ${totalMappedPoints} (visi punkti)`);
        } else {
          console.log(`ğŸ“Š Per-layer sampling (${userSamplingPercent}% katrs ${samplingInterval}. punkts):`);
          Object.keys(layerCounters).forEach(layerName => {
            const totalInLayer = layerCounters[layerName];
            const mappedInLayer = Math.floor(totalInLayer / samplingInterval);
            totalMappedPoints += mappedInLayer;
            if (totalInLayer > 0) {
              console.log(`   ${layerName}: ${totalInLayer} total â†’ ${mappedInLayer} mapped (${userSamplingPercent}%)`);
            }
          });
          console.log(`ğŸ¯ Total mapped points: ${totalMappedPoints} (${userSamplingPercent}% sampling from ${validPoints})`);
        }
      console.log(`âš¡ VeiktspÄ“ja: ${processingTime}s, ${pointsPerSecond} punkti/s`);
      
      // BrÄ«dinÄjums, ja nav derÄ«gu punktu
      if (validPoints === 0 && totalPoints > 0) {
        console.warn('âš ï¸ PROBLÄ’MA: Nav atrasts neviens derÄ«gs punkts!');
        console.warn('IespÄ“jamie iemesli:');
        console.warn('1. LAS un GeoTIFF faili pÄrklÄj daÅ¾Ädas teritorijas');
        console.warn('2. KoordinÄtu sistÄ“mas ir atÅ¡Ä·irÄ«gas');
        console.warn('3. GeoTIFF fails ir nepareizs Å¡ai teritorijai');
      }
      
      return {
        type: "FeatureCollection",
        crs: {
          type: "name",
          properties: {
            name: "urn:ogc:def:crs:EPSG::4326"
          }
        },
        features: features
      };
    }

    function createDXF() {
      const colorMapping = {
        "Diff_plus 1 m and more": 1,
        "Diff_plus 0.5 - 1.0 m": 6,
        "Diff_plus 0.2 - 0.5 m": 231,
        "Diff_plus 0.1 - 0.2 m": 224,
        "Diff_plus 0 - 0.1 m": 3,
        "Diff_minus 0 - 0.1 m": 123,
        "Diff_minus 0.1 - 0.2 m": 151,
        "Diff_minus 0.2 - 0.5 m": 5,
        "Diff_minus 0.5 - 1.0 m": 131,
        "Diff_minus 1 m and more": 170
      };
      let dxfContent = "0\nSECTION\n2\nENTITIES\n";
      
      // Izmantojam GeoJSON datus, ja tie ir pieejami
      const dataSource = currentGeojsonData ? currentGeojsonData.features : [];
      
      dataSource.forEach(feature => {
        const x = feature.properties.CSV_X;
        const y = feature.properties.CSV_Y;
        const z = feature.properties.CSV_Z;
        const tiffZ = feature.properties.DEM_Z;
        const diff = feature.properties.difference;
        let layerName = "Undefined";
        if (diff >= 0) {
          if (diff >= 1.0) layerName = "Diff_plus 1 m and more";
          else if (diff >= 0.5) layerName = "Diff_plus 0.5 - 1.0 m";
          else if (diff >= 0.2) layerName = "Diff_plus 0.2 - 0.5 m";
          else if (diff >= 0.1) layerName = "Diff_plus 0.1 - 0.2 m";
          else layerName = "Diff_plus 0 - 0.1 m";
        } else {
          if (diff <= -1.0) layerName = "Diff_minus 1 m and more";
          else if (diff <= -0.5) layerName = "Diff_minus 0.5 - 1.0 m";
          else if (diff <= -0.2) layerName = "Diff_minus 0.2 - 0.5 m";
          else if (diff <= -0.1) layerName = "Diff_minus 0.1 - 0.2 m";
          else layerName = "Diff_minus 0 - 0.1 m";
        }
        const color = colorMapping[layerName] || 0;
        dxfContent += "0\nPOINT\n";
        dxfContent += "8\n" + layerName + "\n";
        dxfContent += "62\n" + color + "\n";
        dxfContent += "10\n" + x + "\n";
        dxfContent += "20\n" + y + "\n";
        dxfContent += "30\n" + z + "\n";
        dxfContent += "0\nTEXT\n";
        dxfContent += "8\n" + layerName + "\n";
        dxfContent += "62\n" + color + "\n";  
        dxfContent += "10\n" + x + "\n";      
        dxfContent += "20\n" + y + "\n";      
        dxfContent += "40\n0.2\n";
        // IzmainÄ«ts: neizmantojam Math.abs, lai negatÄ«vÄ zÄ«me (-) tiktu saglabÄta
        dxfContent += "1\n" + diff.toFixed(2) + " diff" + "\n";
        dxfContent += "0\nTEXT\n";
        dxfContent += "8\nCSV_Z\n";            
        dxfContent += "62\n7\n";               
        dxfContent += "10\n" + x + "\n";
        dxfContent += "20\n" + y + "\n";
        dxfContent += "40\n0.2\n";
        dxfContent += "72\n2\n";               
        dxfContent += "73\n1\n";               
        dxfContent += "11\n" + x + "\n";       
        dxfContent += "21\n" + y + "\n";       
        dxfContent += "1\n" + z.toFixed(2) + "\n";
        dxfContent += "0\nTEXT\n";
        dxfContent += "8\nDEM_Z\n";            
        dxfContent += "62\n7\n";               
        dxfContent += "10\n" + x + "\n";
        dxfContent += "20\n" + y + "\n";
        dxfContent += "40\n0.2\n";
        dxfContent += "72\n2\n";               
        dxfContent += "73\n3\n";               
        dxfContent += "11\n" + x + "\n";       
        dxfContent += "21\n" + y + "\n";       
        dxfContent += "1\n" + tiffZ.toFixed(2) + "\n";
      });
      dxfContent += "0\nENDSEC\n0\nEOF";
      return dxfContent;
    }

    function downloadFile(filename, text) {
      const blob = new Blob([text], { type: "application/vnd.geo+json" });
      const link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = filename;
      link.click();
    }

    function exportTableAsCSV(geojsonData) {
      let csvText = "#,Punkta_X,Punkta_Y,Punkta_Z,DEM_Z,Diff\n";
      
      // Now GeoJSON contains ALL points, so use it directly
      geojsonData.features.forEach((feature, index) => {
        const row = [
          index + 1,
          feature.properties.CSV_X.toFixed(3),
          feature.properties.CSV_Y.toFixed(3),
          feature.properties.CSV_Z.toFixed(2),
          feature.properties.DEM_Z.toFixed(2),
          feature.properties.difference.toFixed(2)
        ];
        csvText += row.join(",") + "\n";
      });
      return csvText;
    }

    function downloadCSVFile(filename, text) {
      const blob = new Blob([text], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      if (link.download !== undefined) { 
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }

    function exportTableAsXLSX(geojsonData) {
      const data = [];
      data.push(["#", "Punkta_X", "Punkta_Y", "Punkta_Z", "DEM_Z", "Diff"]);
      // Now GeoJSON contains ALL points
      geojsonData.features.forEach((feature, index) => {
        data.push([
          index + 1,
          parseFloat(feature.properties.CSV_X).toFixed(3),  // MainÄ«ts no (2) uz (3)
          parseFloat(feature.properties.CSV_Y).toFixed(3),  // MainÄ«ts no (2) uz (3)
          parseFloat(feature.properties.CSV_Z).toFixed(2),
          parseFloat(feature.properties.DEM_Z).toFixed(2),
          parseFloat(feature.properties.difference).toFixed(2)
        ]);
      });
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Tabula");
      const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([wbout], { type: "application/octet-stream" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `${resultFileName}.xlsx`;
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function calcStats(diffs) {
      // FiltrÄ“ tikai derÄ«gus skaitÄ¼us
      const validDiffs = diffs.filter(val => typeof val === "number" && isFinite(val));
      // Ja masÄ«vs ir pÄrÄk liels vai satur negaidÄ«tas vÄ“rtÄ«bas, atgrieÅ¾am tukÅ¡u statistiku
      if (validDiffs.length === 0 || validDiffs.length > 1000000) return { count: 0, min: 0, max: 0, avg: 0, rmse: 0 };
      const count = validDiffs.length;
      // Izmanto reduce, lai atrastu min un max, nevis izkliedÄ“Å¡anas operatoru
      const minVal = validDiffs.reduce((min, val) => val < min ? val : min, validDiffs[0]);
      const maxVal = validDiffs.reduce((max, val) => val > max ? val : max, validDiffs[0]);
      const sum = validDiffs.reduce((acc, val) => acc + val, 0);
      const avg = sum / count;
      const mse = validDiffs.reduce((acc, val) => acc + val * val, 0) / count;
      const rmse = Math.sqrt(mse);
      return { count, min: minVal, max: maxVal, avg, rmse };
    }

    async function computeStatistics() {
      let posDiffs = [];
      let negDiffs = [];
      let allDiffs = [];
      
      // Now GeoJSON contains ALL points, so use it directly
      if (currentGeojsonData && currentGeojsonData.features) {
        currentGeojsonData.features.forEach(feature => {
          const diff = feature.properties.difference;
          if (!isNaN(diff)) {
        allDiffs.push(diff);
        if (diff >= 0) posDiffs.push(diff); else negDiffs.push(diff);
          }
      });
      }
      // Konsoles izvadam masÄ«vu garumus un saturu
      console.log("posDiffs", posDiffs.length, posDiffs);
      console.log("negDiffs", negDiffs.length, negDiffs);
      console.log("allDiffs", allDiffs.length, allDiffs);
      
      const posStats = calcStats(posDiffs);
      const negStats = calcStats(negDiffs);
      const overallStats = calcStats(allDiffs);
      
      let statsHtml = "<h3>Statistika</h3>";
      
      // KopÄ statistikÄ
      statsHtml += "<h4>KopÄ:</h4>";
      statsHtml += "<p>SalÄ«dzinÄto punktu skaits: " + overallStats.count + "</p>";
      statsHtml += "<p>MinimÄlÄ starpÄ«ba (Î”Z): " + overallStats.min.toFixed(2) + "</p>";
      statsHtml += "<p>MaksimÄlÄ starpÄ«ba (Î”Z): " + overallStats.max.toFixed(2) + "</p>";
      statsHtml += "<p>VidÄ“jÄ starpÄ«ba (Î”Z): " + overallStats.avg.toFixed(2) + "</p>";
      statsHtml += "<p>KvadrÄtiskÄ vidÄ“jÄ kÄ¼Å«da (RMSE): " + overallStats.rmse.toFixed(2) + "</p>";
      
      // AtseviÅ¡Ä·Ä statistika Plus un MÄ«nus vÄ“rtÄ«bÄm
      statsHtml += "<h4>Plus vÄ“rtÄ«bas:</h4>";
      statsHtml += "<p>SalÄ«dzinÄto punktu skaits: " + posStats.count + "</p>";
      statsHtml += "<p>MinimÄlÄ starpÄ«ba (Î”Z): " + posStats.min.toFixed(2) + "</p>";
      statsHtml += "<p>MaksimÄlÄ starpÄ«ba (Î”Z): " + posStats.max.toFixed(2) + "</p>";
      statsHtml += "<p>VidÄ“jÄ starpÄ«ba (Î”Z): " + posStats.avg.toFixed(2) + "</p>";
      statsHtml += "<p>KvadrÄtiskÄ vidÄ“jÄ kÄ¼Å«da (RMSE): " + posStats.rmse.toFixed(2) + "</p>";
      
      statsHtml += "<h4>MÄ«nus vÄ“rtÄ«bas:</h4>";
      statsHtml += "<p>SalÄ«dzinÄto punktu skaits: " + negStats.count + "</p>";
      statsHtml += "<p>MinimÄlÄ starpÄ«ba (Î”Z): " + negStats.min.toFixed(2) + "</p>";
      statsHtml += "<p>MaksimÄlÄ starpÄ«ba (Î”Z): " + negStats.max.toFixed(2) + "</p>";
      statsHtml += "<p>VidÄ“jÄ starpÄ«ba (Î”Z): " + negStats.avg.toFixed(2) + "</p>";
      statsHtml += "<p>KvadrÄtiskÄ vidÄ“jÄ kÄ¼Å«da (RMSE): " + negStats.rmse.toFixed(2) + "</p>";
      
      // KlasifikÄcijas tabulu Ä£enerÄ“Å¡ana...
      let plusCounts = {
        "1 m and more": 0,
        "0.5 - 1.0 m": 0,
        "0.2 - 0.5 m": 0,
        "0.1 - 0.2 m": 0,
        "0 - 0.1 m": 0
      };
      let minusCounts = {
        "0 - 0.1 m": 0,
        "0.1 - 0.2 m": 0,
        "0.2 - 0.5 m": 0,
        "0.5 - 1.0 m": 0,
        "1 m and more": 0
      };
      const plusColorMap = {
        "1 m and more": "#FF0000",
        "0.5 - 1.0 m": "#C80032",
        "0.2 - 0.5 m": "#E57373",
        "0.1 - 0.2 m": "#FFCDD2",
        "0 - 0.1 m": "#8BC34A"
      };
      const minusColorMap = {
        "0 - 0.1 m": "#8BC34A",
        "0.1 - 0.2 m": "#B3E5FC",
        "0.2 - 0.5 m": "#64B5F6",
        "0.5 - 1.0 m": "#1976D2",
        "1 m and more": "#0000FF"
      };
      
      // Now GeoJSON contains ALL points, so use it directly
      if (currentGeojsonData && currentGeojsonData.features) {
        currentGeojsonData.features.forEach(feature => {
          const diff = feature.properties.difference;
          if (isNaN(diff)) return;
          
        if (diff >= 0) {
          if (diff >= 1.0) plusCounts["1 m and more"]++;
          else if (diff >= 0.5) plusCounts["0.5 - 1.0 m"]++;
          else if (diff >= 0.2) plusCounts["0.2 - 0.5 m"]++;
          else if (diff >= 0.1) plusCounts["0.1 - 0.2 m"]++;
          else plusCounts["0 - 0.1 m"]++;
        } else {
          if (diff <= -1.0) minusCounts["1 m and more"]++;
          else if (diff <= -0.5) minusCounts["0.5 - 1.0 m"]++;
          else if (diff <= -0.2) minusCounts["0.2 - 0.5 m"]++;
          else if (diff <= -0.1) minusCounts["0.1 - 0.2 m"]++;
          else minusCounts["0 - 0.1 m"]++;
        }
      });
      }
      
      statsHtml += "<h3>KÄ¼Å«du klasifikÄcija:</h3>";
      statsHtml += "<h4>Plus vÄ“rtÄ«bas (Î”Z â‰¥ 0):</h4>";
      statsHtml += "<table style='width:100%; table-layout: fixed;'><colgroup><col style='width:40%;'><col style='width:30%;'><col style='width:30%;'></colgroup>";
      statsHtml += "<tr><th>IntervÄls</th><th>KrÄsa</th><th>Punktu skaits</th></tr>";
      Object.keys(plusCounts).forEach(interval => {
        statsHtml += "<tr><td>" + interval + "</td><td style='background-color:" + plusColorMap[interval] + ";'></td><td>" + plusCounts[interval] + "</td></tr>";
      });
      statsHtml += "</table>";
      statsHtml += "<h4>MÄ«nus vÄ“rtÄ«bas (Î”Z < 0):</h4>";
      statsHtml += "<table style='width:100%; table-layout: fixed;'><colgroup><col style='width:40%;'><col style='width:30%;'><col style='width:30%;'></colgroup>";
      statsHtml += "<tr><th>IntervÄls</th><th>KrÄsa</th><th>Punktu skaits</th></tr>";
      Object.keys(minusCounts).forEach(interval => {
        statsHtml += "<tr><td>" + interval + "</td><td style='background-color:" + minusColorMap[interval] + ";'></td><td>" + minusCounts[interval] + "</td></tr>";
      });
      statsHtml += "</table>";
      
      document.getElementById("statistics").innerHTML = statsHtml;
    }

    function addLegend() {
      // Remove any existing legend
      if (window.mapLegend) {
        map.removeControl(window.mapLegend);
      }
      window.mapLegend = L.control({ position: 'bottomright' });
      window.mapLegend.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'legend');
        // Define your intervals and associated colors
        const labels = [
          "1 m un vairÄk",
          "0.5 m - 1.0 m",
          "0.2 m - 0.5 m",
          "0.1 m - 0.2 m",
          "0.0 m - 0.1 m",
          "-0.1 m - 0.0 m",
          "-0.2 m - -0.1 m",
          "-0.5 m - -0.2 m",
          "-1.0 m - -0.5 m",
          "-1 m un vairÄk"
        ];
        const colors = [
          '#FF0000',
          '#C80032',
          '#E57373',
          '#FFCDD2',
          '#8BC34A',
          '#8BC34A',
          '#B3E5FC',
          '#64B5F6',
          '#1976D2',
          '#0000FF'
        ];
        // Build the legend HTML
        div.innerHTML += "<h4>LeÄ£enda</h4>";
        for (let i = 0; i < labels.length; i++) {
          div.innerHTML +=
            '<i style="background:' + colors[i] + '; width:18px; height:18px; display:inline-block; margin-right:8px;"></i>' +
            labels[i] + '<br>';
        }
        return div;
      };
      window.mapLegend.addTo(map);
    }
  </script>
</body>
</html>
